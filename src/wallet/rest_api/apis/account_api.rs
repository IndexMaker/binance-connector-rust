/*
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::wallet::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountApi: Send + Sync {
    async fn account_api_trading_status(
        &self,
        params: AccountApiTradingStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountApiTradingStatusResponse>>;
    async fn account_info(
        &self,
        params: AccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountInfoResponse>>;
    async fn account_status(
        &self,
        params: AccountStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountStatusResponse>>;
    async fn daily_account_snapshot(
        &self,
        params: DailyAccountSnapshotParams,
    ) -> anyhow::Result<RestApiResponse<models::DailyAccountSnapshotResponse>>;
    async fn disable_fast_withdraw_switch(
        &self,
        params: DisableFastWithdrawSwitchParams,
    ) -> anyhow::Result<RestApiResponse<Value>>;
    async fn enable_fast_withdraw_switch(
        &self,
        params: EnableFastWithdrawSwitchParams,
    ) -> anyhow::Result<RestApiResponse<Value>>;
    async fn get_api_key_permission(
        &self,
        params: GetApiKeyPermissionParams,
    ) -> anyhow::Result<RestApiResponse<models::GetApiKeyPermissionResponse>>;
}

#[derive(Debug, Clone)]
pub struct AccountApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`account_api_trading_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`account_api_trading_status`](#method.account_api_trading_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AccountApiTradingStatusParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AccountApiTradingStatusParams {
    /// Create a builder for [`account_api_trading_status`].
    ///
    #[must_use]
    pub fn builder() -> AccountApiTradingStatusParamsBuilder {
        AccountApiTradingStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`account_info`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`account_info`](#method.account_info).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AccountInfoParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AccountInfoParams {
    /// Create a builder for [`account_info`].
    ///
    #[must_use]
    pub fn builder() -> AccountInfoParamsBuilder {
        AccountInfoParamsBuilder::default()
    }
}
/// Request parameters for the [`account_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`account_status`](#method.account_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AccountStatusParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AccountStatusParams {
    /// Create a builder for [`account_status`].
    ///
    #[must_use]
    pub fn builder() -> AccountStatusParamsBuilder {
        AccountStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`daily_account_snapshot`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`daily_account_snapshot`](#method.daily_account_snapshot).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DailyAccountSnapshotParams {
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: String,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// min 7, max 30, default 7
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DailyAccountSnapshotParams {
    /// Create a builder for [`daily_account_snapshot`].
    ///
    /// Required parameters:
    ///
    /// * `r#type` â€” String
    ///
    #[must_use]
    pub fn builder(r#type: String) -> DailyAccountSnapshotParamsBuilder {
        DailyAccountSnapshotParamsBuilder::default().r#type(r#type)
    }
}
/// Request parameters for the [`disable_fast_withdraw_switch`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`disable_fast_withdraw_switch`](#method.disable_fast_withdraw_switch).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DisableFastWithdrawSwitchParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DisableFastWithdrawSwitchParams {
    /// Create a builder for [`disable_fast_withdraw_switch`].
    ///
    #[must_use]
    pub fn builder() -> DisableFastWithdrawSwitchParamsBuilder {
        DisableFastWithdrawSwitchParamsBuilder::default()
    }
}
/// Request parameters for the [`enable_fast_withdraw_switch`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`enable_fast_withdraw_switch`](#method.enable_fast_withdraw_switch).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct EnableFastWithdrawSwitchParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl EnableFastWithdrawSwitchParams {
    /// Create a builder for [`enable_fast_withdraw_switch`].
    ///
    #[must_use]
    pub fn builder() -> EnableFastWithdrawSwitchParamsBuilder {
        EnableFastWithdrawSwitchParamsBuilder::default()
    }
}
/// Request parameters for the [`get_api_key_permission`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_api_key_permission`](#method.get_api_key_permission).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetApiKeyPermissionParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetApiKeyPermissionParams {
    /// Create a builder for [`get_api_key_permission`].
    ///
    #[must_use]
    pub fn builder() -> GetApiKeyPermissionParamsBuilder {
        GetApiKeyPermissionParamsBuilder::default()
    }
}

#[async_trait]
impl AccountApi for AccountApiClient {
    async fn account_api_trading_status(
        &self,
        params: AccountApiTradingStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountApiTradingStatusResponse>> {
        let AccountApiTradingStatusParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AccountApiTradingStatusResponse>(
            &self.configuration,
            "/sapi/v1/account/apiTradingStatus",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn account_info(
        &self,
        params: AccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountInfoResponse>> {
        let AccountInfoParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AccountInfoResponse>(
            &self.configuration,
            "/sapi/v1/account/info",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn account_status(
        &self,
        params: AccountStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountStatusResponse>> {
        let AccountStatusParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AccountStatusResponse>(
            &self.configuration,
            "/sapi/v1/account/status",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn daily_account_snapshot(
        &self,
        params: DailyAccountSnapshotParams,
    ) -> anyhow::Result<RestApiResponse<models::DailyAccountSnapshotResponse>> {
        let DailyAccountSnapshotParams {
            r#type,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::DailyAccountSnapshotResponse>(
            &self.configuration,
            "/sapi/v1/accountSnapshot",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn disable_fast_withdraw_switch(
        &self,
        params: DisableFastWithdrawSwitchParams,
    ) -> anyhow::Result<RestApiResponse<Value>> {
        let DisableFastWithdrawSwitchParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Value>(
            &self.configuration,
            "/sapi/v1/account/disableFastWithdrawSwitch",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn enable_fast_withdraw_switch(
        &self,
        params: EnableFastWithdrawSwitchParams,
    ) -> anyhow::Result<RestApiResponse<Value>> {
        let EnableFastWithdrawSwitchParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Value>(
            &self.configuration,
            "/sapi/v1/account/enableFastWithdrawSwitch",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_api_key_permission(
        &self,
        params: GetApiKeyPermissionParams,
    ) -> anyhow::Result<RestApiResponse<models::GetApiKeyPermissionResponse>> {
        let GetApiKeyPermissionParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetApiKeyPermissionResponse>(
            &self.configuration,
            "/sapi/v1/account/apiRestrictions",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "wallet"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountApi for MockAccountApiClient {
        async fn account_api_trading_status(
            &self,
            _params: AccountApiTradingStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::AccountApiTradingStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"data":{"isLocked":false,"plannedRecoverTime":0,"triggerCondition":{"GCR":150,"IFER":150,"UFR":300},"updateTime":1547630471725}}"#).unwrap();
            let dummy_response: models::AccountApiTradingStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountApiTradingStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn account_info(
            &self,
            _params: AccountInfoParams,
        ) -> anyhow::Result<RestApiResponse<models::AccountInfoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"vipLevel":0,"isMarginEnabled":true,"isFutureEnabled":true,"isOptionsEnabled":true,"isPortfolioMarginRetailEnabled":true}"#).unwrap();
            let dummy_response: models::AccountInfoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountInfoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn account_status(
            &self,
            _params: AccountStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::AccountStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"data":"Normal"}"#).unwrap();
            let dummy_response: models::AccountStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn daily_account_snapshot(
            &self,
            _params: DailyAccountSnapshotParams,
        ) -> anyhow::Result<RestApiResponse<models::DailyAccountSnapshotResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"","snapshotVos":[{"data":{"balances":[{"asset":"BTC","free":"0.09905021","locked":"0.00000000"},{"asset":"USDT","free":"1.89109409","locked":"0.00000000"}],"totalAssetOfBtc":"0.09942700"},"type":"spot","updateTime":1576281599000},{"data":{"marginLevel":"2748.02909813","totalAssetOfBtc":"0.00274803","totalLiabilityOfBtc":"0.00000100","totalNetAssetOfBtc":"0.00274750","userAssets":[{"asset":"XRP","borrowed":"0.00000000","free":"1.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"1.00000000"}]},"type":"margin","updateTime":1576281599000},{"data":{"assets":[{"asset":"USDT","marginBalance":"118.99782335","walletBalance":"120.23811389"}],"position":[{"entryPrice":"7130.41000000","markPrice":"7257.66239673","positionAmt":"0.01000000","symbol":"BTCUSDT","unRealizedProfit":"1.24029054"}]},"type":"futures","updateTime":1576281599000}]}"#).unwrap();
            let dummy_response: models::DailyAccountSnapshotResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DailyAccountSnapshotResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn disable_fast_withdraw_switch(
            &self,
            _params: DisableFastWithdrawSwitchParams,
        ) -> anyhow::Result<RestApiResponse<Value>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let dummy_response = Value::Null;

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn enable_fast_withdraw_switch(
            &self,
            _params: EnableFastWithdrawSwitchParams,
        ) -> anyhow::Result<RestApiResponse<Value>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let dummy_response = Value::Null;

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_api_key_permission(
            &self,
            _params: GetApiKeyPermissionParams,
        ) -> anyhow::Result<RestApiResponse<models::GetApiKeyPermissionResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":false,"createTime":1698645219000,"enableReading":true,"enableWithdrawals":false,"enableInternalTransfer":false,"enableMargin":false,"enableFutures":false,"permitsUniversalTransfer":false,"enableVanillaOptions":false,"enableFixApiTrade":false,"enableFixReadOnly":true,"enableSpotAndMarginTrading":false,"enablePortfolioMarginTrading":true}"#).unwrap();
            let dummy_response: models::GetApiKeyPermissionResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetApiKeyPermissionResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn account_api_trading_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountApiTradingStatusParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"data":{"isLocked":false,"plannedRecoverTime":0,"triggerCondition":{"GCR":150,"IFER":150,"UFR":300},"updateTime":1547630471725}}"#).unwrap();
            let expected_response : models::AccountApiTradingStatusResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountApiTradingStatusResponse");

            let resp = client.account_api_trading_status(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_api_trading_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountApiTradingStatusParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"data":{"isLocked":false,"plannedRecoverTime":0,"triggerCondition":{"GCR":150,"IFER":150,"UFR":300},"updateTime":1547630471725}}"#).unwrap();
            let expected_response : models::AccountApiTradingStatusResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountApiTradingStatusResponse");

            let resp = client.account_api_trading_status(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_api_trading_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AccountApiTradingStatusParams::builder().build().unwrap();

            match client.account_api_trading_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn account_info_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountInfoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"vipLevel":0,"isMarginEnabled":true,"isFutureEnabled":true,"isOptionsEnabled":true,"isPortfolioMarginRetailEnabled":true}"#).unwrap();
            let expected_response : models::AccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountInfoResponse");

            let resp = client.account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_info_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountInfoParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"vipLevel":0,"isMarginEnabled":true,"isFutureEnabled":true,"isOptionsEnabled":true,"isPortfolioMarginRetailEnabled":true}"#).unwrap();
            let expected_response : models::AccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountInfoResponse");

            let resp = client.account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_info_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AccountInfoParams::builder().build().unwrap();

            match client.account_info(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn account_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountStatusParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"data":"Normal"}"#).unwrap();
            let expected_response: models::AccountStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountStatusResponse");

            let resp = client
                .account_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountStatusParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"data":"Normal"}"#).unwrap();
            let expected_response: models::AccountStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountStatusResponse");

            let resp = client
                .account_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AccountStatusParams::builder().build().unwrap();

            match client.account_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn daily_account_snapshot_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DailyAccountSnapshotParams::builder("r#type_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"","snapshotVos":[{"data":{"balances":[{"asset":"BTC","free":"0.09905021","locked":"0.00000000"},{"asset":"USDT","free":"1.89109409","locked":"0.00000000"}],"totalAssetOfBtc":"0.09942700"},"type":"spot","updateTime":1576281599000},{"data":{"marginLevel":"2748.02909813","totalAssetOfBtc":"0.00274803","totalLiabilityOfBtc":"0.00000100","totalNetAssetOfBtc":"0.00274750","userAssets":[{"asset":"XRP","borrowed":"0.00000000","free":"1.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"1.00000000"}]},"type":"margin","updateTime":1576281599000},{"data":{"assets":[{"asset":"USDT","marginBalance":"118.99782335","walletBalance":"120.23811389"}],"position":[{"entryPrice":"7130.41000000","markPrice":"7257.66239673","positionAmt":"0.01000000","symbol":"BTCUSDT","unRealizedProfit":"1.24029054"}]},"type":"futures","updateTime":1576281599000}]}"#).unwrap();
            let expected_response : models::DailyAccountSnapshotResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DailyAccountSnapshotResponse");

            let resp = client.daily_account_snapshot(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn daily_account_snapshot_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DailyAccountSnapshotParams::builder("r#type_example".to_string(),).start_time(1623319461670).end_time(1641782889000).limit(7).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"","snapshotVos":[{"data":{"balances":[{"asset":"BTC","free":"0.09905021","locked":"0.00000000"},{"asset":"USDT","free":"1.89109409","locked":"0.00000000"}],"totalAssetOfBtc":"0.09942700"},"type":"spot","updateTime":1576281599000},{"data":{"marginLevel":"2748.02909813","totalAssetOfBtc":"0.00274803","totalLiabilityOfBtc":"0.00000100","totalNetAssetOfBtc":"0.00274750","userAssets":[{"asset":"XRP","borrowed":"0.00000000","free":"1.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"1.00000000"}]},"type":"margin","updateTime":1576281599000},{"data":{"assets":[{"asset":"USDT","marginBalance":"118.99782335","walletBalance":"120.23811389"}],"position":[{"entryPrice":"7130.41000000","markPrice":"7257.66239673","positionAmt":"0.01000000","symbol":"BTCUSDT","unRealizedProfit":"1.24029054"}]},"type":"futures","updateTime":1576281599000}]}"#).unwrap();
            let expected_response : models::DailyAccountSnapshotResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DailyAccountSnapshotResponse");

            let resp = client.daily_account_snapshot(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn daily_account_snapshot_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = DailyAccountSnapshotParams::builder("r#type_example".to_string())
                .build()
                .unwrap();

            match client.daily_account_snapshot(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn disable_fast_withdraw_switch_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DisableFastWithdrawSwitchParams::builder().build().unwrap();

            let expected_response = Value::Null;

            let resp = client
                .disable_fast_withdraw_switch(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn disable_fast_withdraw_switch_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DisableFastWithdrawSwitchParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let expected_response = Value::Null;

            let resp = client
                .disable_fast_withdraw_switch(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn disable_fast_withdraw_switch_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = DisableFastWithdrawSwitchParams::builder().build().unwrap();

            match client.disable_fast_withdraw_switch(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn enable_fast_withdraw_switch_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = EnableFastWithdrawSwitchParams::builder().build().unwrap();

            let expected_response = Value::Null;

            let resp = client
                .enable_fast_withdraw_switch(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_fast_withdraw_switch_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = EnableFastWithdrawSwitchParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let expected_response = Value::Null;

            let resp = client
                .enable_fast_withdraw_switch(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_fast_withdraw_switch_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = EnableFastWithdrawSwitchParams::builder().build().unwrap();

            match client.enable_fast_withdraw_switch(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_api_key_permission_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetApiKeyPermissionParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":false,"createTime":1698645219000,"enableReading":true,"enableWithdrawals":false,"enableInternalTransfer":false,"enableMargin":false,"enableFutures":false,"permitsUniversalTransfer":false,"enableVanillaOptions":false,"enableFixApiTrade":false,"enableFixReadOnly":true,"enableSpotAndMarginTrading":false,"enablePortfolioMarginTrading":true}"#).unwrap();
            let expected_response : models::GetApiKeyPermissionResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetApiKeyPermissionResponse");

            let resp = client.get_api_key_permission(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_api_key_permission_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetApiKeyPermissionParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":false,"createTime":1698645219000,"enableReading":true,"enableWithdrawals":false,"enableInternalTransfer":false,"enableMargin":false,"enableFutures":false,"permitsUniversalTransfer":false,"enableVanillaOptions":false,"enableFixApiTrade":false,"enableFixReadOnly":true,"enableSpotAndMarginTrading":false,"enablePortfolioMarginTrading":true}"#).unwrap();
            let expected_response : models::GetApiKeyPermissionResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetApiKeyPermissionResponse");

            let resp = client.get_api_key_permission(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_api_key_permission_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetApiKeyPermissionParams::builder().build().unwrap();

            match client.get_api_key_permission(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
