/*
 * Binance Sub Account REST API
 *
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::sub_account::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait ApiManagementApi: Send + Sync {
    async fn add_ip_restriction_for_sub_account_api_key(
        &self,
        params: AddIpRestrictionForSubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::AddIpRestrictionForSubAccountApiKeyResponse>>;
    async fn delete_ip_list_for_a_sub_account_api_key(
        &self,
        params: DeleteIpListForASubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteIpListForASubAccountApiKeyResponse>>;
    async fn get_ip_restriction_for_a_sub_account_api_key(
        &self,
        params: GetIpRestrictionForASubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::GetIpRestrictionForASubAccountApiKeyResponse>>;
}

#[derive(Debug, Clone)]
pub struct ApiManagementApiClient {
    configuration: ConfigurationRestApi,
}

impl ApiManagementApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`add_ip_restriction_for_sub_account_api_key`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`add_ip_restriction_for_sub_account_api_key`](#method.add_ip_restriction_for_sub_account_api_key).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AddIpRestrictionForSubAccountApiKeyParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `sub_account_api_key` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub sub_account_api_key: String,
    /// IP Restriction status. 1 = IP Unrestricted. 2 = Restrict access to trusted IPs only.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub status: String,
    /// Insert static IP in batch, separated by commas.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub ip_address: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AddIpRestrictionForSubAccountApiKeyParams {
    /// Create a builder for [`add_ip_restriction_for_sub_account_api_key`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    /// * `sub_account_api_key` — String
    /// * `status` — IP Restriction status. 1 = IP Unrestricted. 2 = Restrict access to trusted IPs only.
    ///
    #[must_use]
    pub fn builder(
        email: String,
        sub_account_api_key: String,
        status: String,
    ) -> AddIpRestrictionForSubAccountApiKeyParamsBuilder {
        AddIpRestrictionForSubAccountApiKeyParamsBuilder::default()
            .email(email)
            .sub_account_api_key(sub_account_api_key)
            .status(status)
    }
}
/// Request parameters for the [`delete_ip_list_for_a_sub_account_api_key`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`delete_ip_list_for_a_sub_account_api_key`](#method.delete_ip_list_for_a_sub_account_api_key).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DeleteIpListForASubAccountApiKeyParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `sub_account_api_key` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub sub_account_api_key: String,
    /// IPs to be deleted. Can be added in batches, separated by commas
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub ip_address: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DeleteIpListForASubAccountApiKeyParams {
    /// Create a builder for [`delete_ip_list_for_a_sub_account_api_key`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    /// * `sub_account_api_key` — String
    /// * `ip_address` — IPs to be deleted. Can be added in batches, separated by commas
    ///
    #[must_use]
    pub fn builder(
        email: String,
        sub_account_api_key: String,
        ip_address: String,
    ) -> DeleteIpListForASubAccountApiKeyParamsBuilder {
        DeleteIpListForASubAccountApiKeyParamsBuilder::default()
            .email(email)
            .sub_account_api_key(sub_account_api_key)
            .ip_address(ip_address)
    }
}
/// Request parameters for the [`get_ip_restriction_for_a_sub_account_api_key`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_ip_restriction_for_a_sub_account_api_key`](#method.get_ip_restriction_for_a_sub_account_api_key).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetIpRestrictionForASubAccountApiKeyParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `sub_account_api_key` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub sub_account_api_key: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetIpRestrictionForASubAccountApiKeyParams {
    /// Create a builder for [`get_ip_restriction_for_a_sub_account_api_key`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    /// * `sub_account_api_key` — String
    ///
    #[must_use]
    pub fn builder(
        email: String,
        sub_account_api_key: String,
    ) -> GetIpRestrictionForASubAccountApiKeyParamsBuilder {
        GetIpRestrictionForASubAccountApiKeyParamsBuilder::default()
            .email(email)
            .sub_account_api_key(sub_account_api_key)
    }
}

#[async_trait]
impl ApiManagementApi for ApiManagementApiClient {
    async fn add_ip_restriction_for_sub_account_api_key(
        &self,
        params: AddIpRestrictionForSubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::AddIpRestrictionForSubAccountApiKeyResponse>> {
        let AddIpRestrictionForSubAccountApiKeyParams {
            email,
            sub_account_api_key,
            status,
            ip_address,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        query_params.insert("subAccountApiKey".to_string(), json!(sub_account_api_key));

        query_params.insert("status".to_string(), json!(status));

        if let Some(rw) = ip_address {
            query_params.insert("ipAddress".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AddIpRestrictionForSubAccountApiKeyResponse>(
            &self.configuration,
            "/sapi/v2/sub-account/subAccountApi/ipRestriction",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn delete_ip_list_for_a_sub_account_api_key(
        &self,
        params: DeleteIpListForASubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteIpListForASubAccountApiKeyResponse>> {
        let DeleteIpListForASubAccountApiKeyParams {
            email,
            sub_account_api_key,
            ip_address,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        query_params.insert("subAccountApiKey".to_string(), json!(sub_account_api_key));

        query_params.insert("ipAddress".to_string(), json!(ip_address));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::DeleteIpListForASubAccountApiKeyResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_ip_restriction_for_a_sub_account_api_key(
        &self,
        params: GetIpRestrictionForASubAccountApiKeyParams,
    ) -> anyhow::Result<RestApiResponse<models::GetIpRestrictionForASubAccountApiKeyResponse>> {
        let GetIpRestrictionForASubAccountApiKeyParams {
            email,
            sub_account_api_key,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        query_params.insert("subAccountApiKey".to_string(), json!(sub_account_api_key));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetIpRestrictionForASubAccountApiKeyResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/subAccountApi/ipRestriction",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "sub_account"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockApiManagementApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl ApiManagementApi for MockApiManagementApiClient {
        async fn add_ip_restriction_for_sub_account_api_key(
            &self,
            _params: AddIpRestrictionForSubAccountApiKeyParams,
        ) -> anyhow::Result<RestApiResponse<models::AddIpRestrictionForSubAccountApiKeyResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"status":"2","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let dummy_response: models::AddIpRestrictionForSubAccountApiKeyResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::AddIpRestrictionForSubAccountApiKeyResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn delete_ip_list_for_a_sub_account_api_key(
            &self,
            _params: DeleteIpListForASubAccountApiKeyParams,
        ) -> anyhow::Result<RestApiResponse<models::DeleteIpListForASubAccountApiKeyResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let dummy_response: models::DeleteIpListForASubAccountApiKeyResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DeleteIpListForASubAccountApiKeyResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_ip_restriction_for_a_sub_account_api_key(
            &self,
            _params: GetIpRestrictionForASubAccountApiKeyParams,
        ) -> anyhow::Result<RestApiResponse<models::GetIpRestrictionForASubAccountApiKeyResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let dummy_response: models::GetIpRestrictionForASubAccountApiKeyResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetIpRestrictionForASubAccountApiKeyResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn add_ip_restriction_for_sub_account_api_key_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = AddIpRestrictionForSubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),"status_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"status":"2","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::AddIpRestrictionForSubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AddIpRestrictionForSubAccountApiKeyResponse");

            let resp = client.add_ip_restriction_for_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn add_ip_restriction_for_sub_account_api_key_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = AddIpRestrictionForSubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),"status_example".to_string(),).ip_address("ip_address_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"status":"2","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::AddIpRestrictionForSubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AddIpRestrictionForSubAccountApiKeyResponse");

            let resp = client.add_ip_restriction_for_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn add_ip_restriction_for_sub_account_api_key_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: true };

            let params = AddIpRestrictionForSubAccountApiKeyParams::builder(
                "sub-account-email@email.com".to_string(),
                "sub_account_api_key_example".to_string(),
                "status_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .add_ip_restriction_for_sub_account_api_key(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn delete_ip_list_for_a_sub_account_api_key_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = DeleteIpListForASubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),"ip_address_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::DeleteIpListForASubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteIpListForASubAccountApiKeyResponse");

            let resp = client.delete_ip_list_for_a_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_ip_list_for_a_sub_account_api_key_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = DeleteIpListForASubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),"ip_address_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::DeleteIpListForASubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteIpListForASubAccountApiKeyResponse");

            let resp = client.delete_ip_list_for_a_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_ip_list_for_a_sub_account_api_key_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: true };

            let params = DeleteIpListForASubAccountApiKeyParams::builder(
                "sub-account-email@email.com".to_string(),
                "sub_account_api_key_example".to_string(),
                "ip_address_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .delete_ip_list_for_a_sub_account_api_key(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_ip_restriction_for_a_sub_account_api_key_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = GetIpRestrictionForASubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::GetIpRestrictionForASubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetIpRestrictionForASubAccountApiKeyResponse");

            let resp = client.get_ip_restriction_for_a_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_ip_restriction_for_a_sub_account_api_key_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: false };

            let params = GetIpRestrictionForASubAccountApiKeyParams::builder("sub-account-email@email.com".to_string(),"sub_account_api_key_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"ipRestrict":"true","ipList":["69.210.67.14","8.34.21.10"],"updateTime":1636371437000,"apiKey":"k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"}"#).unwrap();
            let expected_response : models::GetIpRestrictionForASubAccountApiKeyResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetIpRestrictionForASubAccountApiKeyResponse");

            let resp = client.get_ip_restriction_for_a_sub_account_api_key(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_ip_restriction_for_a_sub_account_api_key_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockApiManagementApiClient { force_error: true };

            let params = GetIpRestrictionForASubAccountApiKeyParams::builder(
                "sub-account-email@email.com".to_string(),
                "sub_account_api_key_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .get_ip_restriction_for_a_sub_account_api_key(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
