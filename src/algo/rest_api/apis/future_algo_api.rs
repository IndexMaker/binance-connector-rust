/*
 * Binance Algo REST API
 *
 * OpenAPI Specification for the Binance Algo REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::algo::rest_api::models;
use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait FutureAlgoApi: Send + Sync {
    async fn cancel_algo_order_future_algo(
        &self,
        params: CancelAlgoOrderFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAlgoOrderFutureAlgoResponse>>;
    async fn query_current_algo_open_orders_future_algo(
        &self,
        params: QueryCurrentAlgoOpenOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse>>;
    async fn query_historical_algo_orders_future_algo(
        &self,
        params: QueryHistoricalAlgoOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryHistoricalAlgoOrdersFutureAlgoResponse>>;
    async fn query_sub_orders_future_algo(
        &self,
        params: QuerySubOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubOrdersFutureAlgoResponse>>;
    async fn time_weighted_average_price_future_algo(
        &self,
        params: TimeWeightedAveragePriceFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::TimeWeightedAveragePriceFutureAlgoResponse>>;
    async fn volume_participation_future_algo(
        &self,
        params: VolumeParticipationFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::VolumeParticipationFutureAlgoResponse>>;
}

#[derive(Debug, Clone)]
pub struct FutureAlgoApiClient {
    configuration: ConfigurationRestApi,
}

impl FutureAlgoApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`cancel_algo_order_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_algo_order_future_algo`](#method.cancel_algo_order_future_algo).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelAlgoOrderFutureAlgoParams {
    /// eg. 14511
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub algo_id: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelAlgoOrderFutureAlgoParams {
    /// Create a builder for [`cancel_algo_order_future_algo`].
    ///
    /// Required parameters:
    ///
    /// * `algo_id` — eg. 14511
    ///
    #[must_use]
    pub fn builder(algo_id: i64) -> CancelAlgoOrderFutureAlgoParamsBuilder {
        CancelAlgoOrderFutureAlgoParamsBuilder::default().algo_id(algo_id)
    }
}
/// Request parameters for the [`query_current_algo_open_orders_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_algo_open_orders_future_algo`](#method.query_current_algo_open_orders_future_algo).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentAlgoOpenOrdersFutureAlgoParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentAlgoOpenOrdersFutureAlgoParams {
    /// Create a builder for [`query_current_algo_open_orders_future_algo`].
    ///
    #[must_use]
    pub fn builder() -> QueryCurrentAlgoOpenOrdersFutureAlgoParamsBuilder {
        QueryCurrentAlgoOpenOrdersFutureAlgoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_historical_algo_orders_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_historical_algo_orders_future_algo`](#method.query_historical_algo_orders_future_algo).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryHistoricalAlgoOrdersFutureAlgoParams {
    /// Trading symbol eg. BTCUSDT
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// BUY or SELL
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub side: Option<String>,
    /// in milliseconds  eg.1641522717552
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// in milliseconds  eg.1641522526562
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default is 1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page: Option<i64>,
    /// MIN 1, MAX 100; Default 100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page_size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryHistoricalAlgoOrdersFutureAlgoParams {
    /// Create a builder for [`query_historical_algo_orders_future_algo`].
    ///
    #[must_use]
    pub fn builder() -> QueryHistoricalAlgoOrdersFutureAlgoParamsBuilder {
        QueryHistoricalAlgoOrdersFutureAlgoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_sub_orders_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_sub_orders_future_algo`](#method.query_sub_orders_future_algo).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QuerySubOrdersFutureAlgoParams {
    /// eg. 14511
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub algo_id: i64,
    /// Default is 1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page: Option<i64>,
    /// MIN 1, MAX 100; Default 100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page_size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QuerySubOrdersFutureAlgoParams {
    /// Create a builder for [`query_sub_orders_future_algo`].
    ///
    /// Required parameters:
    ///
    /// * `algo_id` — eg. 14511
    ///
    #[must_use]
    pub fn builder(algo_id: i64) -> QuerySubOrdersFutureAlgoParamsBuilder {
        QuerySubOrdersFutureAlgoParamsBuilder::default().algo_id(algo_id)
    }
}
/// Request parameters for the [`time_weighted_average_price_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`time_weighted_average_price_future_algo`](#method.time_weighted_average_price_future_algo).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TimeWeightedAveragePriceFutureAlgoParams {
    /// Trading symbol eg. BTCUSDT
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Trading side ( BUY or SELL )
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: String,
    /// Quantity of base asset; Maximum notional per order is 200k, 2mm or 10mm, depending on symbol. Please reduce your size if you order is above the maximum notional per order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    /// Duration for TWAP orders in seconds. [300, 86400]
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub duration: i64,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<String>,
    /// A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub client_algo_id: Option<String>,
    /// "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<bool>,
    /// Limit price of the order; If it is not sent, will place order by market price by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_price: Option<f32>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl TimeWeightedAveragePriceFutureAlgoParams {
    /// Create a builder for [`time_weighted_average_price_future_algo`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — Trading symbol eg. BTCUSDT
    /// * `side` — Trading side ( BUY or SELL )
    /// * `quantity` — Quantity of base asset; Maximum notional per order is 200k, 2mm or 10mm, depending on symbol. Please reduce your size if you order is above the maximum notional per order.
    /// * `duration` — Duration for TWAP orders in seconds. [300, 86400]
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: String,
        quantity: f32,
        duration: i64,
    ) -> TimeWeightedAveragePriceFutureAlgoParamsBuilder {
        TimeWeightedAveragePriceFutureAlgoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .duration(duration)
    }
}
/// Request parameters for the [`volume_participation_future_algo`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`volume_participation_future_algo`](#method.volume_participation_future_algo).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct VolumeParticipationFutureAlgoParams {
    /// Trading symbol eg. BTCUSDT
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Trading side ( BUY or SELL )
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: String,
    /// Quantity of base asset; Maximum notional per order is 200k, 2mm or 10mm, depending on symbol. Please reduce your size if you order is above the maximum notional per order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    /// Represent the relative speed of the current execution; ENUM: LOW, MEDIUM, HIGH
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub urgency: String,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<String>,
    /// A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub client_algo_id: Option<String>,
    /// "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<bool>,
    /// Limit price of the order; If it is not sent, will place order by market price by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_price: Option<f32>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl VolumeParticipationFutureAlgoParams {
    /// Create a builder for [`volume_participation_future_algo`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — Trading symbol eg. BTCUSDT
    /// * `side` — Trading side ( BUY or SELL )
    /// * `quantity` — Quantity of base asset; Maximum notional per order is 200k, 2mm or 10mm, depending on symbol. Please reduce your size if you order is above the maximum notional per order.
    /// * `urgency` — Represent the relative speed of the current execution; ENUM: LOW, MEDIUM, HIGH
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: String,
        quantity: f32,
        urgency: String,
    ) -> VolumeParticipationFutureAlgoParamsBuilder {
        VolumeParticipationFutureAlgoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .urgency(urgency)
    }
}

#[async_trait]
impl FutureAlgoApi for FutureAlgoApiClient {
    async fn cancel_algo_order_future_algo(
        &self,
        params: CancelAlgoOrderFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAlgoOrderFutureAlgoResponse>> {
        let CancelAlgoOrderFutureAlgoParams {
            algo_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("algoId".to_string(), json!(algo_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelAlgoOrderFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_algo_open_orders_future_algo(
        &self,
        params: QueryCurrentAlgoOpenOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse>> {
        let QueryCurrentAlgoOpenOrdersFutureAlgoParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_historical_algo_orders_future_algo(
        &self,
        params: QueryHistoricalAlgoOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryHistoricalAlgoOrdersFutureAlgoResponse>> {
        let QueryHistoricalAlgoOrdersFutureAlgoParams {
            symbol,
            side,
            start_time,
            end_time,
            page,
            page_size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = side {
            query_params.insert("side".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = page {
            query_params.insert("page".to_string(), json!(rw));
        }

        if let Some(rw) = page_size {
            query_params.insert("pageSize".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryHistoricalAlgoOrdersFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/historicalOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_sub_orders_future_algo(
        &self,
        params: QuerySubOrdersFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubOrdersFutureAlgoResponse>> {
        let QuerySubOrdersFutureAlgoParams {
            algo_id,
            page,
            page_size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("algoId".to_string(), json!(algo_id));

        if let Some(rw) = page {
            query_params.insert("page".to_string(), json!(rw));
        }

        if let Some(rw) = page_size {
            query_params.insert("pageSize".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QuerySubOrdersFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/subOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn time_weighted_average_price_future_algo(
        &self,
        params: TimeWeightedAveragePriceFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::TimeWeightedAveragePriceFutureAlgoResponse>> {
        let TimeWeightedAveragePriceFutureAlgoParams {
            symbol,
            side,
            quantity,
            duration,
            position_side,
            client_algo_id,
            reduce_only,
            limit_price,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        let quantity_value = Decimal::from_f32(quantity).unwrap_or_default();
        query_params.insert("quantity".to_string(), json!(quantity_value));

        query_params.insert("duration".to_string(), json!(duration));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = client_algo_id {
            query_params.insert("clientAlgoId".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = limit_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("limitPrice".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::TimeWeightedAveragePriceFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/newOrderTwap",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn volume_participation_future_algo(
        &self,
        params: VolumeParticipationFutureAlgoParams,
    ) -> anyhow::Result<RestApiResponse<models::VolumeParticipationFutureAlgoResponse>> {
        let VolumeParticipationFutureAlgoParams {
            symbol,
            side,
            quantity,
            urgency,
            position_side,
            client_algo_id,
            reduce_only,
            limit_price,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        let quantity_value = Decimal::from_f32(quantity).unwrap_or_default();
        query_params.insert("quantity".to_string(), json!(quantity_value));

        query_params.insert("urgency".to_string(), json!(urgency));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = client_algo_id {
            query_params.insert("clientAlgoId".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = limit_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("limitPrice".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::VolumeParticipationFutureAlgoResponse>(
            &self.configuration,
            "/sapi/v1/algo/futures/newOrderVp",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "algo"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockFutureAlgoApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl FutureAlgoApi for MockFutureAlgoApiClient {
        async fn cancel_algo_order_future_algo(
            &self,
            _params: CancelAlgoOrderFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelAlgoOrderFutureAlgoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"algoId":14511,"success":true,"code":0,"msg":"OK"}"#)
                    .unwrap();
            let dummy_response: models::CancelAlgoOrderFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAlgoOrderFutureAlgoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_algo_open_orders_future_algo(
            &self,
            _params: QueryCurrentAlgoOpenOrdersFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14517,"symbol":"ETHUSDT","side":"SELL","positionSide":"SHORT","totalQty":"5.000","executedQty":"0.000","executedAmt":"0.00000000","avgPrice":"0.00","clientAlgoId":"d7096549481642f8a0bb69e9e2e31f2e","bookTime":1649756817004,"endTime":0,"algoStatus":"WORKING","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let dummy_response: models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_historical_algo_orders_future_algo(
            &self,
            _params: QueryHistoricalAlgoOrdersFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryHistoricalAlgoOrdersFutureAlgoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14518,"symbol":"BNBUSDT","side":"BUY","positionSide":"BOTH","totalQty":"100.00","executedQty":"0.00","executedAmt":"0.00000000","avgPrice":"0.000","clientAlgoId":"acacab56b3c44bef9f6a8f8ebd2a8408","bookTime":1649757019503,"endTime":1649757088101,"algoStatus":"CANCELLED","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let dummy_response: models::QueryHistoricalAlgoOrdersFutureAlgoResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryHistoricalAlgoOrdersFutureAlgoResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_sub_orders_future_algo(
            &self,
            _params: QuerySubOrdersFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::QuerySubOrdersFutureAlgoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"executedQty":"1.000","executedAmt":"3229.44000000","subOrders":[{"algoId":13723,"orderId":8389765519993909000,"orderStatus":"FILLED","executedQty":"1.000","executedAmt":"3229.44000000","feeAmt":"-1.61471999","feeAsset":"USDT","bookTime":1649319001964,"avgPrice":"3229.44","side":"SELL","symbol":"ETHUSDT","subId":1,"timeInForce":"IMMEDIATE_OR_CANCEL","origQty":"1.000"}]}"#).unwrap();
            let dummy_response: models::QuerySubOrdersFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QuerySubOrdersFutureAlgoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn time_weighted_average_price_future_algo(
            &self,
            _params: TimeWeightedAveragePriceFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::TimeWeightedAveragePriceFutureAlgoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"65ce1630101a480b85915d7e11fd5078","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let dummy_response: models::TimeWeightedAveragePriceFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TimeWeightedAveragePriceFutureAlgoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn volume_participation_future_algo(
            &self,
            _params: VolumeParticipationFutureAlgoParams,
        ) -> anyhow::Result<RestApiResponse<models::VolumeParticipationFutureAlgoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"00358ce6a268403398bd34eaa36dffe7","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let dummy_response: models::VolumeParticipationFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::VolumeParticipationFutureAlgoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn cancel_algo_order_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = CancelAlgoOrderFutureAlgoParams::builder(1).build().unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"algoId":14511,"success":true,"code":0,"msg":"OK"}"#)
                    .unwrap();
            let expected_response: models::CancelAlgoOrderFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAlgoOrderFutureAlgoResponse");

            let resp = client
                .cancel_algo_order_future_algo(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_algo_order_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = CancelAlgoOrderFutureAlgoParams::builder(1)
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"algoId":14511,"success":true,"code":0,"msg":"OK"}"#)
                    .unwrap();
            let expected_response: models::CancelAlgoOrderFutureAlgoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAlgoOrderFutureAlgoResponse");

            let resp = client
                .cancel_algo_order_future_algo(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_algo_order_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = CancelAlgoOrderFutureAlgoParams::builder(1).build().unwrap();

            match client.cancel_algo_order_future_algo(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_algo_open_orders_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QueryCurrentAlgoOpenOrdersFutureAlgoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14517,"symbol":"ETHUSDT","side":"SELL","positionSide":"SHORT","totalQty":"5.000","executedQty":"0.000","executedAmt":"0.00000000","avgPrice":"0.00","clientAlgoId":"d7096549481642f8a0bb69e9e2e31f2e","bookTime":1649756817004,"endTime":0,"algoStatus":"WORKING","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let expected_response : models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse");

            let resp = client.query_current_algo_open_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_algo_open_orders_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QueryCurrentAlgoOpenOrdersFutureAlgoParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14517,"symbol":"ETHUSDT","side":"SELL","positionSide":"SHORT","totalQty":"5.000","executedQty":"0.000","executedAmt":"0.00000000","avgPrice":"0.00","clientAlgoId":"d7096549481642f8a0bb69e9e2e31f2e","bookTime":1649756817004,"endTime":0,"algoStatus":"WORKING","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let expected_response : models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentAlgoOpenOrdersFutureAlgoResponse");

            let resp = client.query_current_algo_open_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_algo_open_orders_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = QueryCurrentAlgoOpenOrdersFutureAlgoParams::builder()
                .build()
                .unwrap();

            match client
                .query_current_algo_open_orders_future_algo(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_historical_algo_orders_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QueryHistoricalAlgoOrdersFutureAlgoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14518,"symbol":"BNBUSDT","side":"BUY","positionSide":"BOTH","totalQty":"100.00","executedQty":"0.00","executedAmt":"0.00000000","avgPrice":"0.000","clientAlgoId":"acacab56b3c44bef9f6a8f8ebd2a8408","bookTime":1649757019503,"endTime":1649757088101,"algoStatus":"CANCELLED","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let expected_response : models::QueryHistoricalAlgoOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryHistoricalAlgoOrdersFutureAlgoResponse");

            let resp = client.query_historical_algo_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_historical_algo_orders_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QueryHistoricalAlgoOrdersFutureAlgoParams::builder().symbol("BTCUSDT".to_string()).side("BUY".to_string()).start_time(1623319461670).end_time(1641782889000).page(1).page_size(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"orders":[{"algoId":14518,"symbol":"BNBUSDT","side":"BUY","positionSide":"BOTH","totalQty":"100.00","executedQty":"0.00","executedAmt":"0.00000000","avgPrice":"0.000","clientAlgoId":"acacab56b3c44bef9f6a8f8ebd2a8408","bookTime":1649757019503,"endTime":1649757088101,"algoStatus":"CANCELLED","algoType":"VP","urgency":"LOW"}]}"#).unwrap();
            let expected_response : models::QueryHistoricalAlgoOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryHistoricalAlgoOrdersFutureAlgoResponse");

            let resp = client.query_historical_algo_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_historical_algo_orders_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = QueryHistoricalAlgoOrdersFutureAlgoParams::builder()
                .build()
                .unwrap();

            match client
                .query_historical_algo_orders_future_algo(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_sub_orders_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QuerySubOrdersFutureAlgoParams::builder(1,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"executedQty":"1.000","executedAmt":"3229.44000000","subOrders":[{"algoId":13723,"orderId":8389765519993909000,"orderStatus":"FILLED","executedQty":"1.000","executedAmt":"3229.44000000","feeAmt":"-1.61471999","feeAsset":"USDT","bookTime":1649319001964,"avgPrice":"3229.44","side":"SELL","symbol":"ETHUSDT","subId":1,"timeInForce":"IMMEDIATE_OR_CANCEL","origQty":"1.000"}]}"#).unwrap();
            let expected_response : models::QuerySubOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubOrdersFutureAlgoResponse");

            let resp = client.query_sub_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_orders_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = QuerySubOrdersFutureAlgoParams::builder(1,).page(1).page_size(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":1,"executedQty":"1.000","executedAmt":"3229.44000000","subOrders":[{"algoId":13723,"orderId":8389765519993909000,"orderStatus":"FILLED","executedQty":"1.000","executedAmt":"3229.44000000","feeAmt":"-1.61471999","feeAsset":"USDT","bookTime":1649319001964,"avgPrice":"3229.44","side":"SELL","symbol":"ETHUSDT","subId":1,"timeInForce":"IMMEDIATE_OR_CANCEL","origQty":"1.000"}]}"#).unwrap();
            let expected_response : models::QuerySubOrdersFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubOrdersFutureAlgoResponse");

            let resp = client.query_sub_orders_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_orders_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = QuerySubOrdersFutureAlgoParams::builder(1).build().unwrap();

            match client.query_sub_orders_future_algo(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn time_weighted_average_price_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = TimeWeightedAveragePriceFutureAlgoParams::builder("BTCUSDT".to_string(),"BUY".to_string(),1.0,5000,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"65ce1630101a480b85915d7e11fd5078","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let expected_response : models::TimeWeightedAveragePriceFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TimeWeightedAveragePriceFutureAlgoResponse");

            let resp = client.time_weighted_average_price_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn time_weighted_average_price_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = TimeWeightedAveragePriceFutureAlgoParams::builder("BTCUSDT".to_string(),"BUY".to_string(),1.0,5000,).position_side("BOTH".to_string()).client_algo_id("1".to_string()).reduce_only(false).limit_price(1.0).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"65ce1630101a480b85915d7e11fd5078","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let expected_response : models::TimeWeightedAveragePriceFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TimeWeightedAveragePriceFutureAlgoResponse");

            let resp = client.time_weighted_average_price_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn time_weighted_average_price_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = TimeWeightedAveragePriceFutureAlgoParams::builder(
                "BTCUSDT".to_string(),
                "BUY".to_string(),
                1.0,
                5000,
            )
            .build()
            .unwrap();

            match client.time_weighted_average_price_future_algo(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn volume_participation_future_algo_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = VolumeParticipationFutureAlgoParams::builder("BTCUSDT".to_string(),"BUY".to_string(),1.0,"LOW".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"00358ce6a268403398bd34eaa36dffe7","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let expected_response : models::VolumeParticipationFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VolumeParticipationFutureAlgoResponse");

            let resp = client.volume_participation_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn volume_participation_future_algo_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: false };

            let params = VolumeParticipationFutureAlgoParams::builder("BTCUSDT".to_string(),"BUY".to_string(),1.0,"LOW".to_string(),).position_side("BOTH".to_string()).client_algo_id("1".to_string()).reduce_only(false).limit_price(1.0).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientAlgoId":"00358ce6a268403398bd34eaa36dffe7","success":true,"code":0,"msg":"OK"}"#).unwrap();
            let expected_response : models::VolumeParticipationFutureAlgoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VolumeParticipationFutureAlgoResponse");

            let resp = client.volume_participation_future_algo(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn volume_participation_future_algo_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockFutureAlgoApiClient { force_error: true };

            let params = VolumeParticipationFutureAlgoParams::builder(
                "BTCUSDT".to_string(),
                "BUY".to_string(),
                1.0,
                "LOW".to_string(),
            )
            .build()
            .unwrap();

            match client.volume_participation_future_algo(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
