/*
 * Binance Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::derivatives_trading_coin_futures::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountApi: Send + Sync {
    async fn account_information(
        &self,
        params: AccountInformationParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountInformationResponse>>;
    async fn futures_account_balance(
        &self,
        params: FuturesAccountBalanceParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::FuturesAccountBalanceResponseInner>>>;
    async fn get_current_position_mode(
        &self,
        params: GetCurrentPositionModeParams,
    ) -> anyhow::Result<RestApiResponse<models::GetCurrentPositionModeResponse>>;
    async fn get_download_id_for_futures_order_history(
        &self,
        params: GetDownloadIdForFuturesOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesOrderHistoryResponse>>;
    async fn get_download_id_for_futures_trade_history(
        &self,
        params: GetDownloadIdForFuturesTradeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesTradeHistoryResponse>>;
    async fn get_download_id_for_futures_transaction_history(
        &self,
        params: GetDownloadIdForFuturesTransactionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesTransactionHistoryResponse>>;
    async fn get_futures_order_history_download_link_by_id(
        &self,
        params: GetFuturesOrderHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesOrderHistoryDownloadLinkByIdResponse>>;
    async fn get_futures_trade_download_link_by_id(
        &self,
        params: GetFuturesTradeDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesTradeDownloadLinkByIdResponse>>;
    async fn get_futures_transaction_history_download_link_by_id(
        &self,
        params: GetFuturesTransactionHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesTransactionHistoryDownloadLinkByIdResponse>>;
    async fn get_income_history(
        &self,
        params: GetIncomeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetIncomeHistoryResponseInner>>>;
    async fn notional_bracket_for_pair(
        &self,
        params: NotionalBracketForPairParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForPairResponseInner>>>;
    async fn notional_bracket_for_symbol(
        &self,
        params: NotionalBracketForSymbolParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForSymbolResponseInner>>>;
    async fn user_commission_rate(
        &self,
        params: UserCommissionRateParams,
    ) -> anyhow::Result<RestApiResponse<models::UserCommissionRateResponse>>;
}

#[derive(Debug, Clone)]
pub struct AccountApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`account_information`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`account_information`](#method.account_information).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AccountInformationParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AccountInformationParams {
    /// Create a builder for [`account_information`].
    ///
    #[must_use]
    pub fn builder() -> AccountInformationParamsBuilder {
        AccountInformationParamsBuilder::default()
    }
}
/// Request parameters for the [`futures_account_balance`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`futures_account_balance`](#method.futures_account_balance).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct FuturesAccountBalanceParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl FuturesAccountBalanceParams {
    /// Create a builder for [`futures_account_balance`].
    ///
    #[must_use]
    pub fn builder() -> FuturesAccountBalanceParamsBuilder {
        FuturesAccountBalanceParamsBuilder::default()
    }
}
/// Request parameters for the [`get_current_position_mode`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_current_position_mode`](#method.get_current_position_mode).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetCurrentPositionModeParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetCurrentPositionModeParams {
    /// Create a builder for [`get_current_position_mode`].
    ///
    #[must_use]
    pub fn builder() -> GetCurrentPositionModeParamsBuilder {
        GetCurrentPositionModeParamsBuilder::default()
    }
}
/// Request parameters for the [`get_download_id_for_futures_order_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_download_id_for_futures_order_history`](#method.get_download_id_for_futures_order_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetDownloadIdForFuturesOrderHistoryParams {
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub start_time: i64,
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub end_time: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetDownloadIdForFuturesOrderHistoryParams {
    /// Create a builder for [`get_download_id_for_futures_order_history`].
    ///
    /// Required parameters:
    ///
    /// * `start_time` — Timestamp in ms
    /// * `end_time` — Timestamp in ms
    ///
    #[must_use]
    pub fn builder(
        start_time: i64,
        end_time: i64,
    ) -> GetDownloadIdForFuturesOrderHistoryParamsBuilder {
        GetDownloadIdForFuturesOrderHistoryParamsBuilder::default()
            .start_time(start_time)
            .end_time(end_time)
    }
}
/// Request parameters for the [`get_download_id_for_futures_trade_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_download_id_for_futures_trade_history`](#method.get_download_id_for_futures_trade_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetDownloadIdForFuturesTradeHistoryParams {
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub start_time: i64,
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub end_time: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetDownloadIdForFuturesTradeHistoryParams {
    /// Create a builder for [`get_download_id_for_futures_trade_history`].
    ///
    /// Required parameters:
    ///
    /// * `start_time` — Timestamp in ms
    /// * `end_time` — Timestamp in ms
    ///
    #[must_use]
    pub fn builder(
        start_time: i64,
        end_time: i64,
    ) -> GetDownloadIdForFuturesTradeHistoryParamsBuilder {
        GetDownloadIdForFuturesTradeHistoryParamsBuilder::default()
            .start_time(start_time)
            .end_time(end_time)
    }
}
/// Request parameters for the [`get_download_id_for_futures_transaction_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_download_id_for_futures_transaction_history`](#method.get_download_id_for_futures_transaction_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetDownloadIdForFuturesTransactionHistoryParams {
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub start_time: i64,
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub end_time: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetDownloadIdForFuturesTransactionHistoryParams {
    /// Create a builder for [`get_download_id_for_futures_transaction_history`].
    ///
    /// Required parameters:
    ///
    /// * `start_time` — Timestamp in ms
    /// * `end_time` — Timestamp in ms
    ///
    #[must_use]
    pub fn builder(
        start_time: i64,
        end_time: i64,
    ) -> GetDownloadIdForFuturesTransactionHistoryParamsBuilder {
        GetDownloadIdForFuturesTransactionHistoryParamsBuilder::default()
            .start_time(start_time)
            .end_time(end_time)
    }
}
/// Request parameters for the [`get_futures_order_history_download_link_by_id`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_futures_order_history_download_link_by_id`](#method.get_futures_order_history_download_link_by_id).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFuturesOrderHistoryDownloadLinkByIdParams {
    /// get by download id api
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub download_id: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetFuturesOrderHistoryDownloadLinkByIdParams {
    /// Create a builder for [`get_futures_order_history_download_link_by_id`].
    ///
    /// Required parameters:
    ///
    /// * `download_id` — get by download id api
    ///
    #[must_use]
    pub fn builder(download_id: String) -> GetFuturesOrderHistoryDownloadLinkByIdParamsBuilder {
        GetFuturesOrderHistoryDownloadLinkByIdParamsBuilder::default().download_id(download_id)
    }
}
/// Request parameters for the [`get_futures_trade_download_link_by_id`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_futures_trade_download_link_by_id`](#method.get_futures_trade_download_link_by_id).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFuturesTradeDownloadLinkByIdParams {
    /// get by download id api
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub download_id: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetFuturesTradeDownloadLinkByIdParams {
    /// Create a builder for [`get_futures_trade_download_link_by_id`].
    ///
    /// Required parameters:
    ///
    /// * `download_id` — get by download id api
    ///
    #[must_use]
    pub fn builder(download_id: String) -> GetFuturesTradeDownloadLinkByIdParamsBuilder {
        GetFuturesTradeDownloadLinkByIdParamsBuilder::default().download_id(download_id)
    }
}
/// Request parameters for the [`get_futures_transaction_history_download_link_by_id`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_futures_transaction_history_download_link_by_id`](#method.get_futures_transaction_history_download_link_by_id).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFuturesTransactionHistoryDownloadLinkByIdParams {
    /// get by download id api
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub download_id: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetFuturesTransactionHistoryDownloadLinkByIdParams {
    /// Create a builder for [`get_futures_transaction_history_download_link_by_id`].
    ///
    /// Required parameters:
    ///
    /// * `download_id` — get by download id api
    ///
    #[must_use]
    pub fn builder(
        download_id: String,
    ) -> GetFuturesTransactionHistoryDownloadLinkByIdParamsBuilder {
        GetFuturesTransactionHistoryDownloadLinkByIdParamsBuilder::default()
            .download_id(download_id)
    }
}
/// Request parameters for the [`get_income_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_income_history`](#method.get_income_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetIncomeHistoryParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// "`TRANSFER","WELCOME_BONUS`", "`FUNDING_FEE`", "`REALIZED_PNL`", "COMMISSION", "`INSURANCE_CLEAR`", and "`DELIVERED_SETTELMENT`"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub income_type: Option<String>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    ///
    /// The `page` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetIncomeHistoryParams {
    /// Create a builder for [`get_income_history`].
    ///
    #[must_use]
    pub fn builder() -> GetIncomeHistoryParamsBuilder {
        GetIncomeHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`notional_bracket_for_pair`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`notional_bracket_for_pair`](#method.notional_bracket_for_pair).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NotionalBracketForPairParams {
    ///
    /// The `pair` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pair: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NotionalBracketForPairParams {
    /// Create a builder for [`notional_bracket_for_pair`].
    ///
    #[must_use]
    pub fn builder() -> NotionalBracketForPairParamsBuilder {
        NotionalBracketForPairParamsBuilder::default()
    }
}
/// Request parameters for the [`notional_bracket_for_symbol`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`notional_bracket_for_symbol`](#method.notional_bracket_for_symbol).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NotionalBracketForSymbolParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NotionalBracketForSymbolParams {
    /// Create a builder for [`notional_bracket_for_symbol`].
    ///
    #[must_use]
    pub fn builder() -> NotionalBracketForSymbolParamsBuilder {
        NotionalBracketForSymbolParamsBuilder::default()
    }
}
/// Request parameters for the [`user_commission_rate`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`user_commission_rate`](#method.user_commission_rate).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UserCommissionRateParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl UserCommissionRateParams {
    /// Create a builder for [`user_commission_rate`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> UserCommissionRateParamsBuilder {
        UserCommissionRateParamsBuilder::default().symbol(symbol)
    }
}

#[async_trait]
impl AccountApi for AccountApiClient {
    async fn account_information(
        &self,
        params: AccountInformationParams,
    ) -> anyhow::Result<RestApiResponse<models::AccountInformationResponse>> {
        let AccountInformationParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AccountInformationResponse>(
            &self.configuration,
            "/dapi/v1/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn futures_account_balance(
        &self,
        params: FuturesAccountBalanceParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::FuturesAccountBalanceResponseInner>>> {
        let FuturesAccountBalanceParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::FuturesAccountBalanceResponseInner>>(
            &self.configuration,
            "/dapi/v1/balance",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_current_position_mode(
        &self,
        params: GetCurrentPositionModeParams,
    ) -> anyhow::Result<RestApiResponse<models::GetCurrentPositionModeResponse>> {
        let GetCurrentPositionModeParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetCurrentPositionModeResponse>(
            &self.configuration,
            "/dapi/v1/positionSide/dual",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_download_id_for_futures_order_history(
        &self,
        params: GetDownloadIdForFuturesOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesOrderHistoryResponse>> {
        let GetDownloadIdForFuturesOrderHistoryParams {
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("startTime".to_string(), json!(start_time));

        query_params.insert("endTime".to_string(), json!(end_time));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetDownloadIdForFuturesOrderHistoryResponse>(
            &self.configuration,
            "/dapi/v1/order/asyn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_download_id_for_futures_trade_history(
        &self,
        params: GetDownloadIdForFuturesTradeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesTradeHistoryResponse>> {
        let GetDownloadIdForFuturesTradeHistoryParams {
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("startTime".to_string(), json!(start_time));

        query_params.insert("endTime".to_string(), json!(end_time));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetDownloadIdForFuturesTradeHistoryResponse>(
            &self.configuration,
            "/dapi/v1/trade/asyn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_download_id_for_futures_transaction_history(
        &self,
        params: GetDownloadIdForFuturesTransactionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesTransactionHistoryResponse>>
    {
        let GetDownloadIdForFuturesTransactionHistoryParams {
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("startTime".to_string(), json!(start_time));

        query_params.insert("endTime".to_string(), json!(end_time));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetDownloadIdForFuturesTransactionHistoryResponse>(
            &self.configuration,
            "/dapi/v1/income/asyn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_futures_order_history_download_link_by_id(
        &self,
        params: GetFuturesOrderHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesOrderHistoryDownloadLinkByIdResponse>>
    {
        let GetFuturesOrderHistoryDownloadLinkByIdParams {
            download_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("downloadId".to_string(), json!(download_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetFuturesOrderHistoryDownloadLinkByIdResponse>(
            &self.configuration,
            "/dapi/v1/order/asyn/id",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_futures_trade_download_link_by_id(
        &self,
        params: GetFuturesTradeDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesTradeDownloadLinkByIdResponse>> {
        let GetFuturesTradeDownloadLinkByIdParams {
            download_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("downloadId".to_string(), json!(download_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetFuturesTradeDownloadLinkByIdResponse>(
            &self.configuration,
            "/dapi/v1/trade/asyn/id",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_futures_transaction_history_download_link_by_id(
        &self,
        params: GetFuturesTransactionHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesTransactionHistoryDownloadLinkByIdResponse>>
    {
        let GetFuturesTransactionHistoryDownloadLinkByIdParams {
            download_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("downloadId".to_string(), json!(download_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetFuturesTransactionHistoryDownloadLinkByIdResponse>(
            &self.configuration,
            "/dapi/v1/income/asyn/id",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_income_history(
        &self,
        params: GetIncomeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetIncomeHistoryResponseInner>>> {
        let GetIncomeHistoryParams {
            symbol,
            income_type,
            start_time,
            end_time,
            page,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = income_type {
            query_params.insert("incomeType".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = page {
            query_params.insert("page".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::GetIncomeHistoryResponseInner>>(
            &self.configuration,
            "/dapi/v1/income",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn notional_bracket_for_pair(
        &self,
        params: NotionalBracketForPairParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForPairResponseInner>>> {
        let NotionalBracketForPairParams { pair, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = pair {
            query_params.insert("pair".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::NotionalBracketForPairResponseInner>>(
            &self.configuration,
            "/dapi/v1/leverageBracket",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn notional_bracket_for_symbol(
        &self,
        params: NotionalBracketForSymbolParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForSymbolResponseInner>>> {
        let NotionalBracketForSymbolParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::NotionalBracketForSymbolResponseInner>>(
            &self.configuration,
            "/dapi/v2/leverageBracket",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn user_commission_rate(
        &self,
        params: UserCommissionRateParams,
    ) -> anyhow::Result<RestApiResponse<models::UserCommissionRateResponse>> {
        let UserCommissionRateParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::UserCommissionRateResponse>(
            &self.configuration,
            "/dapi/v1/commissionRate",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "derivatives_trading_coin_futures"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountApi for MockAccountApiClient {
        async fn account_information(
            &self,
            _params: AccountInformationParams,
        ) -> anyhow::Result<RestApiResponse<models::AccountInformationResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"asset":"BTC","walletBalance":"0.00241969","unrealizedProfit":"0.00000000","marginBalance":"0.00241969","maintMargin":"0.00000000","initialMargin":"0.00000000","positionInitialMargin":"0.00000000","openOrderInitialMargin":"0.00000000","maxWithdrawAmount":"0.00241969","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1625474304765}],"positions":[{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"BOTH","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"LONG","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"SHORT","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","notionalValue":"0","updateTime":1627026881327}],"canDeposit":true,"canTrade":true,"canWithdraw":true,"feeTier":2,"updateTime":0}"#).unwrap();
            let dummy_response: models::AccountInformationResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AccountInformationResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn futures_account_balance(
            &self,
            _params: FuturesAccountBalanceParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::FuturesAccountBalanceResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"accountAlias":"SgsR","asset":"BTC","balance":"0.00250000","withdrawAvailable":"0.00250000","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1592468353979}]"#).unwrap();
            let dummy_response: Vec<models::FuturesAccountBalanceResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::FuturesAccountBalanceResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_current_position_mode(
            &self,
            _params: GetCurrentPositionModeParams,
        ) -> anyhow::Result<RestApiResponse<models::GetCurrentPositionModeResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"dualSidePosition":true}"#).unwrap();
            let dummy_response: models::GetCurrentPositionModeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetCurrentPositionModeResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_download_id_for_futures_order_history(
            &self,
            _params: GetDownloadIdForFuturesOrderHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesOrderHistoryResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let dummy_response: models::GetDownloadIdForFuturesOrderHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesOrderHistoryResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_download_id_for_futures_trade_history(
            &self,
            _params: GetDownloadIdForFuturesTradeHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForFuturesTradeHistoryResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let dummy_response: models::GetDownloadIdForFuturesTradeHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTradeHistoryResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_download_id_for_futures_transaction_history(
            &self,
            _params: GetDownloadIdForFuturesTransactionHistoryParams,
        ) -> anyhow::Result<
            RestApiResponse<models::GetDownloadIdForFuturesTransactionHistoryResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let dummy_response: models::GetDownloadIdForFuturesTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTransactionHistoryResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_futures_order_history_download_link_by_id(
            &self,
            _params: GetFuturesOrderHistoryDownloadLinkByIdParams,
        ) -> anyhow::Result<RestApiResponse<models::GetFuturesOrderHistoryDownloadLinkByIdResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let dummy_response: models::GetFuturesOrderHistoryDownloadLinkByIdResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetFuturesOrderHistoryDownloadLinkByIdResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_futures_trade_download_link_by_id(
            &self,
            _params: GetFuturesTradeDownloadLinkByIdParams,
        ) -> anyhow::Result<RestApiResponse<models::GetFuturesTradeDownloadLinkByIdResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let dummy_response: models::GetFuturesTradeDownloadLinkByIdResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetFuturesTradeDownloadLinkByIdResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_futures_transaction_history_download_link_by_id(
            &self,
            _params: GetFuturesTransactionHistoryDownloadLinkByIdParams,
        ) -> anyhow::Result<
            RestApiResponse<models::GetFuturesTransactionHistoryDownloadLinkByIdResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let dummy_response : models::GetFuturesTransactionHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesTransactionHistoryDownloadLinkByIdResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_income_history(
            &self,
            _params: GetIncomeHistoryParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::GetIncomeHistoryResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"","incomeType":"TRANSFER","income":"-0.37500000","asset":"BTC","info":"WITHDRAW","time":1570608000000,"tranId":"9689322392","tradeId":""},{"symbol":"BTCUSD_200925","incomeType":"COMMISSION","income":"-0.01000000","asset":"BTC","info":"","time":1570636800000,"tranId":"9689322392","tradeId":"2059192"}]"#).unwrap();
            let dummy_response: Vec<models::GetIncomeHistoryResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::GetIncomeHistoryResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn notional_bracket_for_pair(
            &self,
            _params: NotionalBracketForPairParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForPairResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"pair":"BTCUSD","brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let dummy_response: Vec<models::NotionalBracketForPairResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::NotionalBracketForPairResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn notional_bracket_for_symbol(
            &self,
            _params: NotionalBracketForSymbolParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::NotionalBracketForSymbolResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_PERP","notionalCoef":1.5,"brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let dummy_response: Vec<models::NotionalBracketForSymbolResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::NotionalBracketForSymbolResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn user_commission_rate(
            &self,
            _params: UserCommissionRateParams,
        ) -> anyhow::Result<RestApiResponse<models::UserCommissionRateResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSD_PERP","makerCommissionRate":"0.00015","takerCommissionRate":"0.00040"}"#).unwrap();
            let dummy_response: models::UserCommissionRateResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::UserCommissionRateResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn account_information_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountInformationParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"asset":"BTC","walletBalance":"0.00241969","unrealizedProfit":"0.00000000","marginBalance":"0.00241969","maintMargin":"0.00000000","initialMargin":"0.00000000","positionInitialMargin":"0.00000000","openOrderInitialMargin":"0.00000000","maxWithdrawAmount":"0.00241969","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1625474304765}],"positions":[{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"BOTH","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"LONG","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"SHORT","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","notionalValue":"0","updateTime":1627026881327}],"canDeposit":true,"canTrade":true,"canWithdraw":true,"feeTier":2,"updateTime":0}"#).unwrap();
            let expected_response : models::AccountInformationResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountInformationResponse");

            let resp = client.account_information(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_information_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountInformationParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"asset":"BTC","walletBalance":"0.00241969","unrealizedProfit":"0.00000000","marginBalance":"0.00241969","maintMargin":"0.00000000","initialMargin":"0.00000000","positionInitialMargin":"0.00000000","openOrderInitialMargin":"0.00000000","maxWithdrawAmount":"0.00241969","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1625474304765}],"positions":[{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"BOTH","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"LONG","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","updateTime":0},{"symbol":"BTCUSD_201225","positionAmt":"0","initialMargin":"0","maintMargin":"0","unrealizedProfit":"0.00000000","positionInitialMargin":"0","openOrderInitialMargin":"0","leverage":"125","isolated":false,"positionSide":"SHORT","entryPrice":"0.0","breakEvenPrice":"0.0","maxQty":"50","notionalValue":"0","updateTime":1627026881327}],"canDeposit":true,"canTrade":true,"canWithdraw":true,"feeTier":2,"updateTime":0}"#).unwrap();
            let expected_response : models::AccountInformationResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AccountInformationResponse");

            let resp = client.account_information(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_information_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AccountInformationParams::builder().build().unwrap();

            match client.account_information(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn futures_account_balance_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FuturesAccountBalanceParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"accountAlias":"SgsR","asset":"BTC","balance":"0.00250000","withdrawAvailable":"0.00250000","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1592468353979}]"#).unwrap();
            let expected_response : Vec<models::FuturesAccountBalanceResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::FuturesAccountBalanceResponseInner>");

            let resp = client.futures_account_balance(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn futures_account_balance_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FuturesAccountBalanceParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"accountAlias":"SgsR","asset":"BTC","balance":"0.00250000","withdrawAvailable":"0.00250000","crossWalletBalance":"0.00241969","crossUnPnl":"0.00000000","availableBalance":"0.00241969","updateTime":1592468353979}]"#).unwrap();
            let expected_response : Vec<models::FuturesAccountBalanceResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::FuturesAccountBalanceResponseInner>");

            let resp = client.futures_account_balance(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn futures_account_balance_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = FuturesAccountBalanceParams::builder().build().unwrap();

            match client.futures_account_balance(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_current_position_mode_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetCurrentPositionModeParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"dualSidePosition":true}"#).unwrap();
            let expected_response: models::GetCurrentPositionModeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetCurrentPositionModeResponse");

            let resp = client
                .get_current_position_mode(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_current_position_mode_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetCurrentPositionModeParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"dualSidePosition":true}"#).unwrap();
            let expected_response: models::GetCurrentPositionModeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetCurrentPositionModeResponse");

            let resp = client
                .get_current_position_mode(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_current_position_mode_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetCurrentPositionModeParams::builder().build().unwrap();

            match client.get_current_position_mode(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_download_id_for_futures_order_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params =
                GetDownloadIdForFuturesOrderHistoryParams::builder(1623319461670, 1641782889000)
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesOrderHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesOrderHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_order_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_order_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params =
                GetDownloadIdForFuturesOrderHistoryParams::builder(1623319461670, 1641782889000)
                    .recv_window(5000)
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesOrderHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesOrderHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_order_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_order_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params =
                GetDownloadIdForFuturesOrderHistoryParams::builder(1623319461670, 1641782889000)
                    .build()
                    .unwrap();

            match client
                .get_download_id_for_futures_order_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_download_id_for_futures_trade_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params =
                GetDownloadIdForFuturesTradeHistoryParams::builder(1623319461670, 1641782889000)
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesTradeHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTradeHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_trade_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_trade_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params =
                GetDownloadIdForFuturesTradeHistoryParams::builder(1623319461670, 1641782889000)
                    .recv_window(5000)
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesTradeHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTradeHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_trade_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_trade_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params =
                GetDownloadIdForFuturesTradeHistoryParams::builder(1623319461670, 1641782889000)
                    .build()
                    .unwrap();

            match client
                .get_download_id_for_futures_trade_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_download_id_for_futures_transaction_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetDownloadIdForFuturesTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTransactionHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_transaction_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_transaction_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetDownloadIdForFuturesTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForFuturesTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForFuturesTransactionHistoryResponse",
                );

            let resp = client
                .get_download_id_for_futures_transaction_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_futures_transaction_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetDownloadIdForFuturesTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .build()
            .unwrap();

            match client
                .get_download_id_for_futures_transaction_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_futures_order_history_download_link_by_id_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesOrderHistoryDownloadLinkByIdParams::builder("1".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesOrderHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesOrderHistoryDownloadLinkByIdResponse");

            let resp = client.get_futures_order_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_order_history_download_link_by_id_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesOrderHistoryDownloadLinkByIdParams::builder("1".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesOrderHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesOrderHistoryDownloadLinkByIdResponse");

            let resp = client.get_futures_order_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_order_history_download_link_by_id_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetFuturesOrderHistoryDownloadLinkByIdParams::builder("1".to_string())
                .build()
                .unwrap();

            match client
                .get_futures_order_history_download_link_by_id(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_futures_trade_download_link_by_id_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesTradeDownloadLinkByIdParams::builder("1".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesTradeDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesTradeDownloadLinkByIdResponse");

            let resp = client.get_futures_trade_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_trade_download_link_by_id_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesTradeDownloadLinkByIdParams::builder("1".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesTradeDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesTradeDownloadLinkByIdResponse");

            let resp = client.get_futures_trade_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_trade_download_link_by_id_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetFuturesTradeDownloadLinkByIdParams::builder("1".to_string())
                .build()
                .unwrap();

            match client.get_futures_trade_download_link_by_id(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_futures_transaction_history_download_link_by_id_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesTransactionHistoryDownloadLinkByIdParams::builder("1".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesTransactionHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesTransactionHistoryDownloadLinkByIdResponse");

            let resp = client.get_futures_transaction_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_transaction_history_download_link_by_id_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetFuturesTransactionHistoryDownloadLinkByIdParams::builder("1".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetFuturesTransactionHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesTransactionHistoryDownloadLinkByIdResponse");

            let resp = client.get_futures_transaction_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_transaction_history_download_link_by_id_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params =
                GetFuturesTransactionHistoryDownloadLinkByIdParams::builder("1".to_string())
                    .build()
                    .unwrap();

            match client
                .get_futures_transaction_history_download_link_by_id(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_income_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetIncomeHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"","incomeType":"TRANSFER","income":"-0.37500000","asset":"BTC","info":"WITHDRAW","time":1570608000000,"tranId":"9689322392","tradeId":""},{"symbol":"BTCUSD_200925","incomeType":"COMMISSION","income":"-0.01000000","asset":"BTC","info":"","time":1570636800000,"tranId":"9689322392","tradeId":"2059192"}]"#).unwrap();
            let expected_response : Vec<models::GetIncomeHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetIncomeHistoryResponseInner>");

            let resp = client.get_income_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_income_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetIncomeHistoryParams::builder().symbol("symbol_example".to_string()).income_type("income_type_example".to_string()).start_time(1623319461670).end_time(1641782889000).page(789).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"","incomeType":"TRANSFER","income":"-0.37500000","asset":"BTC","info":"WITHDRAW","time":1570608000000,"tranId":"9689322392","tradeId":""},{"symbol":"BTCUSD_200925","incomeType":"COMMISSION","income":"-0.01000000","asset":"BTC","info":"","time":1570636800000,"tranId":"9689322392","tradeId":"2059192"}]"#).unwrap();
            let expected_response : Vec<models::GetIncomeHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetIncomeHistoryResponseInner>");

            let resp = client.get_income_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_income_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetIncomeHistoryParams::builder().build().unwrap();

            match client.get_income_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn notional_bracket_for_pair_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = NotionalBracketForPairParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"pair":"BTCUSD","brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let expected_response : Vec<models::NotionalBracketForPairResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::NotionalBracketForPairResponseInner>");

            let resp = client.notional_bracket_for_pair(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn notional_bracket_for_pair_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = NotionalBracketForPairParams::builder().pair("pair_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"pair":"BTCUSD","brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let expected_response : Vec<models::NotionalBracketForPairResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::NotionalBracketForPairResponseInner>");

            let resp = client.notional_bracket_for_pair(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn notional_bracket_for_pair_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = NotionalBracketForPairParams::builder().build().unwrap();

            match client.notional_bracket_for_pair(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn notional_bracket_for_symbol_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = NotionalBracketForSymbolParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_PERP","notionalCoef":1.5,"brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let expected_response : Vec<models::NotionalBracketForSymbolResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::NotionalBracketForSymbolResponseInner>");

            let resp = client.notional_bracket_for_symbol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn notional_bracket_for_symbol_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = NotionalBracketForSymbolParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_PERP","notionalCoef":1.5,"brackets":[{"bracket":1,"initialLeverage":125,"qtyCap":50,"qtylFloor":0,"maintMarginRatio":0.004,"cum":0}]}]"#).unwrap();
            let expected_response : Vec<models::NotionalBracketForSymbolResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::NotionalBracketForSymbolResponseInner>");

            let resp = client.notional_bracket_for_symbol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn notional_bracket_for_symbol_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = NotionalBracketForSymbolParams::builder().build().unwrap();

            match client.notional_bracket_for_symbol(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn user_commission_rate_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = UserCommissionRateParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSD_PERP","makerCommissionRate":"0.00015","takerCommissionRate":"0.00040"}"#).unwrap();
            let expected_response : models::UserCommissionRateResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::UserCommissionRateResponse");

            let resp = client.user_commission_rate(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn user_commission_rate_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = UserCommissionRateParams::builder("symbol_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSD_PERP","makerCommissionRate":"0.00015","takerCommissionRate":"0.00040"}"#).unwrap();
            let expected_response : models::UserCommissionRateResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::UserCommissionRateResponse");

            let resp = client.user_commission_rate(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn user_commission_rate_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = UserCommissionRateParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.user_commission_rate(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
