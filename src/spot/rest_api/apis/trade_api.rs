/*
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::spot::rest_api::models;

const HAS_TIME_UNIT: bool = true;

#[async_trait]
pub trait TradeApi: Send + Sync {
    async fn delete_open_orders(
        &self,
        params: DeleteOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::DeleteOpenOrdersResponseInner>>>;
    async fn delete_order(
        &self,
        params: DeleteOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteOrderResponse>>;
    async fn delete_order_list(
        &self,
        params: DeleteOrderListParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteOrderListResponse>>;
    async fn new_order(
        &self,
        params: NewOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewOrderResponse>>;
    async fn order_amend_keep_priority(
        &self,
        params: OrderAmendKeepPriorityParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderAmendKeepPriorityResponse>>;
    async fn order_cancel_replace(
        &self,
        params: OrderCancelReplaceParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderCancelReplaceResponse>>;
    async fn order_list_oco(
        &self,
        params: OrderListOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOcoResponse>>;
    async fn order_list_oto(
        &self,
        params: OrderListOtoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOtoResponse>>;
    async fn order_list_otoco(
        &self,
        params: OrderListOtocoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOtocoResponse>>;
    async fn order_oco(
        &self,
        params: OrderOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderOcoResponse>>;
    async fn order_test(
        &self,
        params: OrderTestParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderTestResponse>>;
    async fn sor_order(
        &self,
        params: SorOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::SorOrderResponse>>;
    async fn sor_order_test(
        &self,
        params: SorOrderTestParams,
    ) -> anyhow::Result<RestApiResponse<models::SorOrderTestResponse>>;
}

#[derive(Debug, Clone)]
pub struct TradeApiClient {
    configuration: ConfigurationRestApi,
}

impl TradeApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeleteOrderCancelRestrictionsEnum {
    #[serde(rename = "ONLY_NEW")]
    OnlyNew,
    #[serde(rename = "NEW")]
    New,
    #[serde(rename = "ONLY_PARTIALLY_FILLED")]
    OnlyPartiallyFilled,
    #[serde(rename = "PARTIALLY_FILLED")]
    PartiallyFilled,
}

impl DeleteOrderCancelRestrictionsEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            DeleteOrderCancelRestrictionsEnum::OnlyNew => "ONLY_NEW",
            DeleteOrderCancelRestrictionsEnum::New => "NEW",
            DeleteOrderCancelRestrictionsEnum::OnlyPartiallyFilled => "ONLY_PARTIALLY_FILLED",
            DeleteOrderCancelRestrictionsEnum::PartiallyFilled => "PARTIALLY_FILLED",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            NewOrderSideEnum::Buy => "BUY",
            NewOrderSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewOrderTypeEnum {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl NewOrderTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            NewOrderTypeEnum::Market => "MARKET",
            NewOrderTypeEnum::Limit => "LIMIT",
            NewOrderTypeEnum::StopLoss => "STOP_LOSS",
            NewOrderTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            NewOrderTypeEnum::TakeProfit => "TAKE_PROFIT",
            NewOrderTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
            NewOrderTypeEnum::LimitMaker => "LIMIT_MAKER",
            NewOrderTypeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl NewOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            NewOrderTimeInForceEnum::Gtc => "GTC",
            NewOrderTimeInForceEnum::Ioc => "IOC",
            NewOrderTimeInForceEnum::Fok => "FOK",
            NewOrderTimeInForceEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewOrderNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl NewOrderNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            NewOrderNewOrderRespTypeEnum::Ack => "ACK",
            NewOrderNewOrderRespTypeEnum::Result => "RESULT",
            NewOrderNewOrderRespTypeEnum::Full => "FULL",
            NewOrderNewOrderRespTypeEnum::Market => "MARKET",
            NewOrderNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewOrderSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl NewOrderSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            NewOrderSelfTradePreventionModeEnum::None => "NONE",
            NewOrderSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            NewOrderSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            NewOrderSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            NewOrderSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            NewOrderSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderCancelReplaceSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceSideEnum::Buy => "BUY",
            OrderCancelReplaceSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceTypeEnum {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderCancelReplaceTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceTypeEnum::Market => "MARKET",
            OrderCancelReplaceTypeEnum::Limit => "LIMIT",
            OrderCancelReplaceTypeEnum::StopLoss => "STOP_LOSS",
            OrderCancelReplaceTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderCancelReplaceTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderCancelReplaceTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
            OrderCancelReplaceTypeEnum::LimitMaker => "LIMIT_MAKER",
            OrderCancelReplaceTypeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceCancelReplaceModeEnum {
    #[serde(rename = "STOP_ON_FAILURE")]
    StopOnFailure,
    #[serde(rename = "ALLOW_FAILURE")]
    AllowFailure,
}

impl OrderCancelReplaceCancelReplaceModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceCancelReplaceModeEnum::StopOnFailure => "STOP_ON_FAILURE",
            OrderCancelReplaceCancelReplaceModeEnum::AllowFailure => "ALLOW_FAILURE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderCancelReplaceTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceTimeInForceEnum::Gtc => "GTC",
            OrderCancelReplaceTimeInForceEnum::Ioc => "IOC",
            OrderCancelReplaceTimeInForceEnum::Fok => "FOK",
            OrderCancelReplaceTimeInForceEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl OrderCancelReplaceNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceNewOrderRespTypeEnum::Ack => "ACK",
            OrderCancelReplaceNewOrderRespTypeEnum::Result => "RESULT",
            OrderCancelReplaceNewOrderRespTypeEnum::Full => "FULL",
            OrderCancelReplaceNewOrderRespTypeEnum::Market => "MARKET",
            OrderCancelReplaceNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderCancelReplaceSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceSelfTradePreventionModeEnum::None => "NONE",
            OrderCancelReplaceSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            OrderCancelReplaceSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            OrderCancelReplaceSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            OrderCancelReplaceSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            OrderCancelReplaceSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceCancelRestrictionsEnum {
    #[serde(rename = "ONLY_NEW")]
    OnlyNew,
    #[serde(rename = "NEW")]
    New,
    #[serde(rename = "ONLY_PARTIALLY_FILLED")]
    OnlyPartiallyFilled,
    #[serde(rename = "PARTIALLY_FILLED")]
    PartiallyFilled,
}

impl OrderCancelReplaceCancelRestrictionsEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceCancelRestrictionsEnum::OnlyNew => "ONLY_NEW",
            OrderCancelReplaceCancelRestrictionsEnum::New => "NEW",
            OrderCancelReplaceCancelRestrictionsEnum::OnlyPartiallyFilled => {
                "ONLY_PARTIALLY_FILLED"
            }
            OrderCancelReplaceCancelRestrictionsEnum::PartiallyFilled => "PARTIALLY_FILLED",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceOrderRateLimitExceededModeEnum {
    #[serde(rename = "DO_NOTHING")]
    DoNothing,
    #[serde(rename = "CANCEL_ONLY")]
    CancelOnly,
}

impl OrderCancelReplaceOrderRateLimitExceededModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceOrderRateLimitExceededModeEnum::DoNothing => "DO_NOTHING",
            OrderCancelReplaceOrderRateLimitExceededModeEnum::CancelOnly => "CANCEL_ONLY",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderListOcoSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoSideEnum::Buy => "BUY",
            OrderListOcoSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoAboveTypeEnum {
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
}

impl OrderListOcoAboveTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoAboveTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOcoAboveTypeEnum::StopLoss => "STOP_LOSS",
            OrderListOcoAboveTypeEnum::LimitMaker => "LIMIT_MAKER",
            OrderListOcoAboveTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderListOcoAboveTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoBelowTypeEnum {
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
}

impl OrderListOcoBelowTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoBelowTypeEnum::StopLoss => "STOP_LOSS",
            OrderListOcoBelowTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOcoBelowTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderListOcoBelowTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoBelowTimeInForceEnum {
    #[serde(rename = "belowType")]
    Belowtype,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
}

impl OrderListOcoBelowTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoBelowTimeInForceEnum::Belowtype => "belowType",
            OrderListOcoBelowTimeInForceEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOcoBelowTimeInForceEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl OrderListOcoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoNewOrderRespTypeEnum::Ack => "ACK",
            OrderListOcoNewOrderRespTypeEnum::Result => "RESULT",
            OrderListOcoNewOrderRespTypeEnum::Full => "FULL",
            OrderListOcoNewOrderRespTypeEnum::Market => "MARKET",
            OrderListOcoNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOcoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderListOcoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOcoSelfTradePreventionModeEnum::None => "NONE",
            OrderListOcoSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            OrderListOcoSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            OrderListOcoSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            OrderListOcoSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            OrderListOcoSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoWorkingTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
}

impl OrderListOtoWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoWorkingTypeEnum::Limit => "LIMIT",
            OrderListOtoWorkingTypeEnum::LimitMaker => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoWorkingSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderListOtoWorkingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoWorkingSideEnum::Buy => "BUY",
            OrderListOtoWorkingSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoPendingTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
}

impl OrderListOtoPendingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoPendingTypeEnum::Limit => "LIMIT",
            OrderListOtoPendingTypeEnum::Market => "MARKET",
            OrderListOtoPendingTypeEnum::StopLoss => "STOP_LOSS",
            OrderListOtoPendingTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOtoPendingTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderListOtoPendingTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
            OrderListOtoPendingTypeEnum::LimitMaker => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoPendingSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderListOtoPendingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoPendingSideEnum::Buy => "BUY",
            OrderListOtoPendingSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl OrderListOtoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoNewOrderRespTypeEnum::Ack => "ACK",
            OrderListOtoNewOrderRespTypeEnum::Result => "RESULT",
            OrderListOtoNewOrderRespTypeEnum::Full => "FULL",
            OrderListOtoNewOrderRespTypeEnum::Market => "MARKET",
            OrderListOtoNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderListOtoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoSelfTradePreventionModeEnum::None => "NONE",
            OrderListOtoSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            OrderListOtoSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            OrderListOtoSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            OrderListOtoSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            OrderListOtoSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoWorkingTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl OrderListOtoWorkingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoWorkingTimeInForceEnum::Gtc => "GTC",
            OrderListOtoWorkingTimeInForceEnum::Ioc => "IOC",
            OrderListOtoWorkingTimeInForceEnum::Fok => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtoPendingTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl OrderListOtoPendingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtoPendingTimeInForceEnum::Gtc => "GTC",
            OrderListOtoPendingTimeInForceEnum::Ioc => "IOC",
            OrderListOtoPendingTimeInForceEnum::Fok => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoWorkingTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
}

impl OrderListOtocoWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoWorkingTypeEnum::Limit => "LIMIT",
            OrderListOtocoWorkingTypeEnum::LimitMaker => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoWorkingSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderListOtocoWorkingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoWorkingSideEnum::Buy => "BUY",
            OrderListOtocoWorkingSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoPendingSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderListOtocoPendingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoPendingSideEnum::Buy => "BUY",
            OrderListOtocoPendingSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoPendingAboveTypeEnum {
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
}

impl OrderListOtocoPendingAboveTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoPendingAboveTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOtocoPendingAboveTypeEnum::StopLoss => "STOP_LOSS",
            OrderListOtocoPendingAboveTypeEnum::LimitMaker => "LIMIT_MAKER",
            OrderListOtocoPendingAboveTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderListOtocoPendingAboveTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl OrderListOtocoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoNewOrderRespTypeEnum::Ack => "ACK",
            OrderListOtocoNewOrderRespTypeEnum::Result => "RESULT",
            OrderListOtocoNewOrderRespTypeEnum::Full => "FULL",
            OrderListOtocoNewOrderRespTypeEnum::Market => "MARKET",
            OrderListOtocoNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderListOtocoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoSelfTradePreventionModeEnum::None => "NONE",
            OrderListOtocoSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            OrderListOtocoSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            OrderListOtocoSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            OrderListOtocoSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            OrderListOtocoSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoWorkingTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl OrderListOtocoWorkingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoWorkingTimeInForceEnum::Gtc => "GTC",
            OrderListOtocoWorkingTimeInForceEnum::Ioc => "IOC",
            OrderListOtocoWorkingTimeInForceEnum::Fok => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoPendingAboveTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl OrderListOtocoPendingAboveTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoPendingAboveTimeInForceEnum::Gtc => "GTC",
            OrderListOtocoPendingAboveTimeInForceEnum::Ioc => "IOC",
            OrderListOtocoPendingAboveTimeInForceEnum::Fok => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoPendingBelowTypeEnum {
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
}

impl OrderListOtocoPendingBelowTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoPendingBelowTypeEnum::StopLoss => "STOP_LOSS",
            OrderListOtocoPendingBelowTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            OrderListOtocoPendingBelowTypeEnum::TakeProfit => "TAKE_PROFIT",
            OrderListOtocoPendingBelowTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListOtocoPendingBelowTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl OrderListOtocoPendingBelowTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListOtocoPendingBelowTimeInForceEnum::Gtc => "GTC",
            OrderListOtocoPendingBelowTimeInForceEnum::Ioc => "IOC",
            OrderListOtocoPendingBelowTimeInForceEnum::Fok => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderOcoSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl OrderOcoSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderOcoSideEnum::Buy => "BUY",
            OrderOcoSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderOcoStopLimitTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl OrderOcoStopLimitTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderOcoStopLimitTimeInForceEnum::Gtc => "GTC",
            OrderOcoStopLimitTimeInForceEnum::Fok => "FOK",
            OrderOcoStopLimitTimeInForceEnum::Ioc => "IOC",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderOcoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl OrderOcoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderOcoNewOrderRespTypeEnum::Ack => "ACK",
            OrderOcoNewOrderRespTypeEnum::Result => "RESULT",
            OrderOcoNewOrderRespTypeEnum::Full => "FULL",
            OrderOcoNewOrderRespTypeEnum::Market => "MARKET",
            OrderOcoNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderOcoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl OrderOcoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderOcoSelfTradePreventionModeEnum::None => "NONE",
            OrderOcoSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            OrderOcoSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            OrderOcoSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            OrderOcoSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            OrderOcoSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl SorOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderSideEnum::Buy => "BUY",
            SorOrderSideEnum::Sell => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderTypeEnum {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    StopLossLimit,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TakeProfitLimit,
    #[serde(rename = "LIMIT_MAKER")]
    LimitMaker,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl SorOrderTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderTypeEnum::Market => "MARKET",
            SorOrderTypeEnum::Limit => "LIMIT",
            SorOrderTypeEnum::StopLoss => "STOP_LOSS",
            SorOrderTypeEnum::StopLossLimit => "STOP_LOSS_LIMIT",
            SorOrderTypeEnum::TakeProfit => "TAKE_PROFIT",
            SorOrderTypeEnum::TakeProfitLimit => "TAKE_PROFIT_LIMIT",
            SorOrderTypeEnum::LimitMaker => "LIMIT_MAKER",
            SorOrderTypeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl SorOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderTimeInForceEnum::Gtc => "GTC",
            SorOrderTimeInForceEnum::Ioc => "IOC",
            SorOrderTimeInForceEnum::Fok => "FOK",
            SorOrderTimeInForceEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
}

impl SorOrderNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderNewOrderRespTypeEnum::Ack => "ACK",
            SorOrderNewOrderRespTypeEnum::Result => "RESULT",
            SorOrderNewOrderRespTypeEnum::Full => "FULL",
            SorOrderNewOrderRespTypeEnum::Market => "MARKET",
            SorOrderNewOrderRespTypeEnum::Limit => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "DECREMENT")]
    Decrement,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl SorOrderSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderSelfTradePreventionModeEnum::None => "NONE",
            SorOrderSelfTradePreventionModeEnum::ExpireTaker => "EXPIRE_TAKER",
            SorOrderSelfTradePreventionModeEnum::ExpireMaker => "EXPIRE_MAKER",
            SorOrderSelfTradePreventionModeEnum::ExpireBoth => "EXPIRE_BOTH",
            SorOrderSelfTradePreventionModeEnum::Decrement => "DECREMENT",
            SorOrderSelfTradePreventionModeEnum::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

/// Request parameters for the [`delete_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`delete_open_orders`](#method.delete_open_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DeleteOpenOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DeleteOpenOrdersParams {
    /// Create a builder for [`delete_open_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DeleteOpenOrdersParamsBuilder {
        DeleteOpenOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`delete_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`delete_order`](#method.delete_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DeleteOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `cancel_restrictions` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_restrictions: Option<DeleteOrderCancelRestrictionsEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DeleteOrderParams {
    /// Create a builder for [`delete_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DeleteOrderParamsBuilder {
        DeleteOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`delete_order_list`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`delete_order_list`](#method.delete_order_list).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DeleteOrderListParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Either `orderListId` or `listClientOrderId` must be provided
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_list_id: Option<i64>,
    /// A unique Id for the entire orderList
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DeleteOrderListParams {
    /// Create a builder for [`delete_order_list`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DeleteOrderListParamsBuilder {
        DeleteOrderListParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`new_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_order`](#method.new_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewOrderSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: NewOrderTypeEnum,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewOrderTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<f32>,
    ///
    /// The `quote_order_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_order_qty: Option<f32>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// The value cannot be less than `1000000`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    /// Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<i64>,
    /// Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<NewOrderNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<NewOrderSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewOrderParams {
    /// Create a builder for [`new_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewOrderSideEnum,
        r#type: NewOrderTypeEnum,
    ) -> NewOrderParamsBuilder {
        NewOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`order_amend_keep_priority`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_amend_keep_priority`](#method.order_amend_keep_priority).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderAmendKeepPriorityParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// `newQty` must be greater than 0 and less than the order's quantity.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub new_qty: f32,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderAmendKeepPriorityParams {
    /// Create a builder for [`order_amend_keep_priority`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `new_qty` — `newQty` must be greater than 0 and less than the order's quantity.
    ///
    #[must_use]
    pub fn builder(symbol: String, new_qty: f32) -> OrderAmendKeepPriorityParamsBuilder {
        OrderAmendKeepPriorityParamsBuilder::default()
            .symbol(symbol)
            .new_qty(new_qty)
    }
}
/// Request parameters for the [`order_cancel_replace`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_cancel_replace`](#method.order_cancel_replace).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderCancelReplaceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderCancelReplaceSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: OrderCancelReplaceTypeEnum,
    ///
    /// The `cancel_replace_mode` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub cancel_replace_mode: OrderCancelReplaceCancelReplaceModeEnum,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<OrderCancelReplaceTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<f32>,
    ///
    /// The `quote_order_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_order_qty: Option<f32>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_new_client_order_id: Option<String>,
    /// Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br> If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br> If both conditions are not met the request will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_orig_client_order_id: Option<String>,
    /// Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br>If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br>If both conditions are not met the request will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_order_id: Option<i64>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// The value cannot be less than `1000000`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    /// Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<i64>,
    /// Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderCancelReplaceNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderCancelReplaceSelfTradePreventionModeEnum>,
    ///
    /// The `cancel_restrictions` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_restrictions: Option<OrderCancelReplaceCancelRestrictionsEnum>,
    ///
    /// The `order_rate_limit_exceeded_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_rate_limit_exceeded_mode: Option<OrderCancelReplaceOrderRateLimitExceededModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderCancelReplaceParams {
    /// Create a builder for [`order_cancel_replace`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — String
    /// * `cancel_replace_mode` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderCancelReplaceSideEnum,
        r#type: OrderCancelReplaceTypeEnum,
        cancel_replace_mode: OrderCancelReplaceCancelReplaceModeEnum,
    ) -> OrderCancelReplaceParamsBuilder {
        OrderCancelReplaceParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
            .cancel_replace_mode(cancel_replace_mode)
    }
}
/// Request parameters for the [`order_list_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_oco`](#method.order_list_oco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListOcoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderListOcoSideEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    ///
    /// The `above_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub above_type: OrderListOcoAboveTypeEnum,
    ///
    /// The `below_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub below_type: OrderListOcoBelowTypeEnum,
    /// A unique Id for the entire orderList
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_client_order_id: Option<String>,
    /// Note that this can only be used if `aboveTimeInForce` is `GTC`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_iceberg_qty: Option<i64>,
    /// Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_price: Option<f32>,
    /// Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_trailing_delta: Option<i64>,
    /// Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_time_in_force: Option<f32>,
    /// Arbitrary numeric value identifying the above order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_strategy_type: Option<i32>,
    /// Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_client_order_id: Option<String>,
    /// Note that this can only be used if `belowTimeInForce` is `GTC`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_iceberg_qty: Option<i64>,
    /// Can be used if `belowType` is `STOP_LOSS_LIMIT`, `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_price: Option<f32>,
    /// Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_trailing_delta: Option<i64>,
    ///
    /// The `below_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_time_in_force: Option<OrderListOcoBelowTimeInForceEnum>,
    /// Arbitrary numeric value identifying the below order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_strategy_type: Option<i32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListOcoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListOcoSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListOcoParams {
    /// Create a builder for [`order_list_oco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — f32
    /// * `above_type` — String
    /// * `below_type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderListOcoSideEnum,
        quantity: f32,
        above_type: OrderListOcoAboveTypeEnum,
        below_type: OrderListOcoBelowTypeEnum,
    ) -> OrderListOcoParamsBuilder {
        OrderListOcoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .above_type(above_type)
            .below_type(below_type)
    }
}
/// Request parameters for the [`order_list_oto`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_oto`](#method.order_list_oto).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListOtoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `working_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_type: OrderListOtoWorkingTypeEnum,
    ///
    /// The `working_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_side: OrderListOtoWorkingSideEnum,
    ///
    /// The `working_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_price: f32,
    /// Sets the quantity for the working order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_quantity: f32,
    ///
    /// The `pending_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_type: OrderListOtoPendingTypeEnum,
    ///
    /// The `pending_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_side: OrderListOtoPendingSideEnum,
    /// Sets the quantity for the pending order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_quantity: f32,
    /// A unique Id for the entire orderList
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListOtoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListOtoSelfTradePreventionModeEnum>,
    /// Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_client_order_id: Option<String>,
    /// This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_iceberg_qty: Option<f32>,
    ///
    /// The `working_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_time_in_force: Option<OrderListOtoWorkingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the working order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_type: Option<i32>,
    /// Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_client_order_id: Option<String>,
    ///
    /// The `pending_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_price: Option<f32>,
    ///
    /// The `pending_stop_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_stop_price: Option<f32>,
    ///
    /// The `pending_trailing_delta` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_trailing_delta: Option<f32>,
    /// This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_iceberg_qty: Option<f32>,
    ///
    /// The `pending_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_time_in_force: Option<OrderListOtoPendingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_strategy_type: Option<i32>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListOtoParams {
    /// Create a builder for [`order_list_oto`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `working_type` — String
    /// * `working_side` — String
    /// * `working_price` — f32
    /// * `working_quantity` — Sets the quantity for the working order.
    /// * `pending_type` — String
    /// * `pending_side` — String
    /// * `pending_quantity` — Sets the quantity for the pending order.
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        working_type: OrderListOtoWorkingTypeEnum,
        working_side: OrderListOtoWorkingSideEnum,
        working_price: f32,
        working_quantity: f32,
        pending_type: OrderListOtoPendingTypeEnum,
        pending_side: OrderListOtoPendingSideEnum,
        pending_quantity: f32,
    ) -> OrderListOtoParamsBuilder {
        OrderListOtoParamsBuilder::default()
            .symbol(symbol)
            .working_type(working_type)
            .working_side(working_side)
            .working_price(working_price)
            .working_quantity(working_quantity)
            .pending_type(pending_type)
            .pending_side(pending_side)
            .pending_quantity(pending_quantity)
    }
}
/// Request parameters for the [`order_list_otoco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_otoco`](#method.order_list_otoco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListOtocoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `working_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_type: OrderListOtocoWorkingTypeEnum,
    ///
    /// The `working_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_side: OrderListOtocoWorkingSideEnum,
    ///
    /// The `working_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_price: f32,
    /// Sets the quantity for the working order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_quantity: f32,
    ///
    /// The `pending_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_side: OrderListOtocoPendingSideEnum,
    /// Sets the quantity for the pending order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_quantity: f32,
    ///
    /// The `pending_above_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_above_type: OrderListOtocoPendingAboveTypeEnum,
    /// A unique Id for the entire orderList
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListOtocoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListOtocoSelfTradePreventionModeEnum>,
    /// Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_client_order_id: Option<String>,
    /// This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_iceberg_qty: Option<f32>,
    ///
    /// The `working_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_time_in_force: Option<OrderListOtocoWorkingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the working order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_type: Option<i32>,
    /// Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_client_order_id: Option<String>,
    /// Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_price: Option<f32>,
    /// Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_stop_price: Option<f32>,
    /// See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_trailing_delta: Option<f32>,
    /// This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_iceberg_qty: Option<f32>,
    ///
    /// The `pending_above_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_time_in_force: Option<OrderListOtocoPendingAboveTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending above order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_strategy_type: Option<i32>,
    ///
    /// The `pending_below_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_type: Option<OrderListOtocoPendingBelowTypeEnum>,
    /// Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_client_order_id: Option<String>,
    /// Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_price: Option<f32>,
    /// Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_stop_price: Option<f32>,
    ///
    /// The `pending_below_trailing_delta` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_trailing_delta: Option<f32>,
    /// This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_iceberg_qty: Option<f32>,
    ///
    /// The `pending_below_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_time_in_force: Option<OrderListOtocoPendingBelowTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending below order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_strategy_type: Option<i32>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListOtocoParams {
    /// Create a builder for [`order_list_otoco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `working_type` — String
    /// * `working_side` — String
    /// * `working_price` — f32
    /// * `working_quantity` — Sets the quantity for the working order.
    /// * `pending_side` — String
    /// * `pending_quantity` — Sets the quantity for the pending order.
    /// * `pending_above_type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        working_type: OrderListOtocoWorkingTypeEnum,
        working_side: OrderListOtocoWorkingSideEnum,
        working_price: f32,
        working_quantity: f32,
        pending_side: OrderListOtocoPendingSideEnum,
        pending_quantity: f32,
        pending_above_type: OrderListOtocoPendingAboveTypeEnum,
    ) -> OrderListOtocoParamsBuilder {
        OrderListOtocoParamsBuilder::default()
            .symbol(symbol)
            .working_type(working_type)
            .working_side(working_side)
            .working_price(working_price)
            .working_quantity(working_quantity)
            .pending_side(pending_side)
            .pending_quantity(pending_quantity)
            .pending_above_type(pending_above_type)
    }
}
/// Request parameters for the [`order_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_oco`](#method.order_oco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderOcoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderOcoSideEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    ///
    /// The `price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub price: f32,
    ///
    /// The `stop_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub stop_price: f32,
    /// A unique Id for the entire orderList
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// A unique Id for the limit order
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_client_order_id: Option<String>,
    ///
    /// The `limit_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_strategy_id: Option<i64>,
    /// The value cannot be less than `1000000`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_strategy_type: Option<i32>,
    /// Used to make the `LIMIT_MAKER` leg an iceberg order.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_iceberg_qty: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<i64>,
    /// A unique Id for the stop loss/stop loss limit leg
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_client_order_id: Option<String>,
    ///
    /// The `stop_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_strategy_id: Option<i64>,
    /// The value cannot be less than `1000000`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_strategy_type: Option<i32>,
    /// If provided, `stopLimitTimeInForce` is required.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_price: Option<f32>,
    /// Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_iceberg_qty: Option<f32>,
    ///
    /// The `stop_limit_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_time_in_force: Option<OrderOcoStopLimitTimeInForceEnum>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderOcoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderOcoSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderOcoParams {
    /// Create a builder for [`order_oco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — f32
    /// * `price` — f32
    /// * `stop_price` — f32
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderOcoSideEnum,
        quantity: f32,
        price: f32,
        stop_price: f32,
    ) -> OrderOcoParamsBuilder {
        OrderOcoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .price(price)
            .stop_price(stop_price)
    }
}
/// Request parameters for the [`order_test`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_test`](#method.order_test).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderTestParams {
    /// Default: `false`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub compute_commission_rates: Option<bool>,
}

impl OrderTestParams {
    /// Create a builder for [`order_test`].
    ///
    #[must_use]
    pub fn builder() -> OrderTestParamsBuilder {
        OrderTestParamsBuilder::default()
    }
}
/// Request parameters for the [`sor_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`sor_order`](#method.sor_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SorOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: SorOrderSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: SorOrderTypeEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<SorOrderTimeInForceEnum>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    /// A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// The value cannot be less than `1000000`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    /// Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<SorOrderNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<SorOrderSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SorOrderParams {
    /// Create a builder for [`sor_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — String
    /// * `quantity` — f32
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: SorOrderSideEnum,
        r#type: SorOrderTypeEnum,
        quantity: f32,
    ) -> SorOrderParamsBuilder {
        SorOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
            .quantity(quantity)
    }
}
/// Request parameters for the [`sor_order_test`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`sor_order_test`](#method.sor_order_test).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SorOrderTestParams {
    /// Default: `false`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub compute_commission_rates: Option<bool>,
}

impl SorOrderTestParams {
    /// Create a builder for [`sor_order_test`].
    ///
    #[must_use]
    pub fn builder() -> SorOrderTestParamsBuilder {
        SorOrderTestParamsBuilder::default()
    }
}

#[async_trait]
impl TradeApi for TradeApiClient {
    async fn delete_open_orders(
        &self,
        params: DeleteOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::DeleteOpenOrdersResponseInner>>> {
        let DeleteOpenOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::DeleteOpenOrdersResponseInner>>(
            &self.configuration,
            "/api/v3/openOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn delete_order(
        &self,
        params: DeleteOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteOrderResponse>> {
        let DeleteOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            cancel_restrictions,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = cancel_restrictions {
            query_params.insert("cancelRestrictions".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::DeleteOrderResponse>(
            &self.configuration,
            "/api/v3/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn delete_order_list(
        &self,
        params: DeleteOrderListParams,
    ) -> anyhow::Result<RestApiResponse<models::DeleteOrderListResponse>> {
        let DeleteOrderListParams {
            symbol,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_list_id {
            query_params.insert("orderListId".to_string(), json!(rw));
        }

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::DeleteOrderListResponse>(
            &self.configuration,
            "/api/v3/orderList",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_order(
        &self,
        params: NewOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewOrderResponse>> {
        let NewOrderParams {
            symbol,
            side,
            r#type,
            time_in_force,
            quantity,
            quote_order_qty,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = quote_order_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("quoteOrderQty".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_type {
            query_params.insert("strategyType".to_string(), json!(rw));
        }

        if let Some(rw) = stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("stopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = trailing_delta {
            query_params.insert("trailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("icebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewOrderResponse>(
            &self.configuration,
            "/api/v3/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_amend_keep_priority(
        &self,
        params: OrderAmendKeepPriorityParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderAmendKeepPriorityResponse>> {
        let OrderAmendKeepPriorityParams {
            symbol,
            new_qty,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        let new_qty_value = Decimal::from_f32(new_qty).unwrap_or_default();
        query_params.insert("newQty".to_string(), json!(new_qty_value));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderAmendKeepPriorityResponse>(
            &self.configuration,
            "/api/v3/order/amend/keepPriority",
            reqwest::Method::PUT,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_cancel_replace(
        &self,
        params: OrderCancelReplaceParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderCancelReplaceResponse>> {
        let OrderCancelReplaceParams {
            symbol,
            side,
            r#type,
            cancel_replace_mode,
            time_in_force,
            quantity,
            quote_order_qty,
            price,
            cancel_new_client_order_id,
            cancel_orig_client_order_id,
            cancel_order_id,
            new_client_order_id,
            strategy_id,
            strategy_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            cancel_restrictions,
            order_rate_limit_exceeded_mode,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        query_params.insert("cancelReplaceMode".to_string(), json!(cancel_replace_mode));

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = quote_order_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("quoteOrderQty".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = cancel_new_client_order_id {
            query_params.insert("cancelNewClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = cancel_orig_client_order_id {
            query_params.insert("cancelOrigClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = cancel_order_id {
            query_params.insert("cancelOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_type {
            query_params.insert("strategyType".to_string(), json!(rw));
        }

        if let Some(rw) = stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("stopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = trailing_delta {
            query_params.insert("trailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("icebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = cancel_restrictions {
            query_params.insert("cancelRestrictions".to_string(), json!(rw));
        }

        if let Some(rw) = order_rate_limit_exceeded_mode {
            query_params.insert("orderRateLimitExceededMode".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderCancelReplaceResponse>(
            &self.configuration,
            "/api/v3/order/cancelReplace",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_list_oco(
        &self,
        params: OrderListOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOcoResponse>> {
        let OrderListOcoParams {
            symbol,
            side,
            quantity,
            above_type,
            below_type,
            list_client_order_id,
            above_client_order_id,
            above_iceberg_qty,
            above_price,
            above_stop_price,
            above_trailing_delta,
            above_time_in_force,
            above_strategy_id,
            above_strategy_type,
            below_client_order_id,
            below_iceberg_qty,
            below_price,
            below_stop_price,
            below_trailing_delta,
            below_time_in_force,
            below_strategy_id,
            below_strategy_type,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        let quantity_value = Decimal::from_f32(quantity).unwrap_or_default();
        query_params.insert("quantity".to_string(), json!(quantity_value));

        query_params.insert("aboveType".to_string(), json!(above_type));

        query_params.insert("belowType".to_string(), json!(below_type));

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = above_client_order_id {
            query_params.insert("aboveClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = above_iceberg_qty {
            query_params.insert("aboveIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = above_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("abovePrice".to_string(), json!(rw));
        }

        if let Some(rw) = above_stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("aboveStopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = above_trailing_delta {
            query_params.insert("aboveTrailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = above_time_in_force {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("aboveTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = above_strategy_id {
            query_params.insert("aboveStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = above_strategy_type {
            query_params.insert("aboveStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = below_client_order_id {
            query_params.insert("belowClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = below_iceberg_qty {
            query_params.insert("belowIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = below_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("belowPrice".to_string(), json!(rw));
        }

        if let Some(rw) = below_stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("belowStopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = below_trailing_delta {
            query_params.insert("belowTrailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = below_time_in_force {
            query_params.insert("belowTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = below_strategy_id {
            query_params.insert("belowStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = below_strategy_type {
            query_params.insert("belowStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderListOcoResponse>(
            &self.configuration,
            "/api/v3/orderList/oco",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_list_oto(
        &self,
        params: OrderListOtoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOtoResponse>> {
        let OrderListOtoParams {
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_type,
            pending_side,
            pending_quantity,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            pending_client_order_id,
            pending_price,
            pending_stop_price,
            pending_trailing_delta,
            pending_iceberg_qty,
            pending_time_in_force,
            pending_strategy_id,
            pending_strategy_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("workingType".to_string(), json!(working_type));

        query_params.insert("workingSide".to_string(), json!(working_side));

        let working_price_value = Decimal::from_f32(working_price).unwrap_or_default();
        query_params.insert("workingPrice".to_string(), json!(working_price_value));

        let working_quantity_value = Decimal::from_f32(working_quantity).unwrap_or_default();
        query_params.insert("workingQuantity".to_string(), json!(working_quantity_value));

        query_params.insert("pendingType".to_string(), json!(pending_type));

        query_params.insert("pendingSide".to_string(), json!(pending_side));

        let pending_quantity_value = Decimal::from_f32(pending_quantity).unwrap_or_default();
        query_params.insert("pendingQuantity".to_string(), json!(pending_quantity_value));

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = working_client_order_id {
            query_params.insert("workingClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = working_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("workingIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = working_time_in_force {
            query_params.insert("workingTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = working_strategy_id {
            query_params.insert("workingStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = working_strategy_type {
            query_params.insert("workingStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = pending_client_order_id {
            query_params.insert("pendingClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingPrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingStopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_trailing_delta {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingTrailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = pending_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = pending_time_in_force {
            query_params.insert("pendingTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = pending_strategy_id {
            query_params.insert("pendingStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_strategy_type {
            query_params.insert("pendingStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderListOtoResponse>(
            &self.configuration,
            "/api/v3/orderList/oto",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_list_otoco(
        &self,
        params: OrderListOtocoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderListOtocoResponse>> {
        let OrderListOtocoParams {
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_side,
            pending_quantity,
            pending_above_type,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            pending_above_client_order_id,
            pending_above_price,
            pending_above_stop_price,
            pending_above_trailing_delta,
            pending_above_iceberg_qty,
            pending_above_time_in_force,
            pending_above_strategy_id,
            pending_above_strategy_type,
            pending_below_type,
            pending_below_client_order_id,
            pending_below_price,
            pending_below_stop_price,
            pending_below_trailing_delta,
            pending_below_iceberg_qty,
            pending_below_time_in_force,
            pending_below_strategy_id,
            pending_below_strategy_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("workingType".to_string(), json!(working_type));

        query_params.insert("workingSide".to_string(), json!(working_side));

        let working_price_value = Decimal::from_f32(working_price).unwrap_or_default();
        query_params.insert("workingPrice".to_string(), json!(working_price_value));

        let working_quantity_value = Decimal::from_f32(working_quantity).unwrap_or_default();
        query_params.insert("workingQuantity".to_string(), json!(working_quantity_value));

        query_params.insert("pendingSide".to_string(), json!(pending_side));

        let pending_quantity_value = Decimal::from_f32(pending_quantity).unwrap_or_default();
        query_params.insert("pendingQuantity".to_string(), json!(pending_quantity_value));

        query_params.insert("pendingAboveType".to_string(), json!(pending_above_type));

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = working_client_order_id {
            query_params.insert("workingClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = working_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("workingIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = working_time_in_force {
            query_params.insert("workingTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = working_strategy_id {
            query_params.insert("workingStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = working_strategy_type {
            query_params.insert("workingStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_client_order_id {
            query_params.insert("pendingAboveClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingAbovePrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingAboveStopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_trailing_delta {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingAboveTrailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingAboveIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_time_in_force {
            query_params.insert("pendingAboveTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_strategy_id {
            query_params.insert("pendingAboveStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_above_strategy_type {
            query_params.insert("pendingAboveStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_type {
            query_params.insert("pendingBelowType".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_client_order_id {
            query_params.insert("pendingBelowClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingBelowPrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_stop_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingBelowStopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_trailing_delta {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingBelowTrailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("pendingBelowIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_time_in_force {
            query_params.insert("pendingBelowTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_strategy_id {
            query_params.insert("pendingBelowStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = pending_below_strategy_type {
            query_params.insert("pendingBelowStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderListOtocoResponse>(
            &self.configuration,
            "/api/v3/orderList/otoco",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_oco(
        &self,
        params: OrderOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderOcoResponse>> {
        let OrderOcoParams {
            symbol,
            side,
            quantity,
            price,
            stop_price,
            list_client_order_id,
            limit_client_order_id,
            limit_strategy_id,
            limit_strategy_type,
            limit_iceberg_qty,
            trailing_delta,
            stop_client_order_id,
            stop_strategy_id,
            stop_strategy_type,
            stop_limit_price,
            stop_iceberg_qty,
            stop_limit_time_in_force,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        let quantity_value = Decimal::from_f32(quantity).unwrap_or_default();
        query_params.insert("quantity".to_string(), json!(quantity_value));

        let price_value = Decimal::from_f32(price).unwrap_or_default();
        query_params.insert("price".to_string(), json!(price_value));

        let stop_price_value = Decimal::from_f32(stop_price).unwrap_or_default();
        query_params.insert("stopPrice".to_string(), json!(stop_price_value));

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = limit_client_order_id {
            query_params.insert("limitClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = limit_strategy_id {
            query_params.insert("limitStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = limit_strategy_type {
            query_params.insert("limitStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = limit_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("limitIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = trailing_delta {
            query_params.insert("trailingDelta".to_string(), json!(rw));
        }

        if let Some(rw) = stop_client_order_id {
            query_params.insert("stopClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = stop_strategy_id {
            query_params.insert("stopStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = stop_strategy_type {
            query_params.insert("stopStrategyType".to_string(), json!(rw));
        }

        if let Some(rw) = stop_limit_price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("stopLimitPrice".to_string(), json!(rw));
        }

        if let Some(rw) = stop_iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("stopIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = stop_limit_time_in_force {
            query_params.insert("stopLimitTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OrderOcoResponse>(
            &self.configuration,
            "/api/v3/order/oco",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_test(
        &self,
        params: OrderTestParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderTestResponse>> {
        let OrderTestParams {
            compute_commission_rates,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = compute_commission_rates {
            query_params.insert("computeCommissionRates".to_string(), json!(rw));
        }

        send_request::<models::OrderTestResponse>(
            &self.configuration,
            "/api/v3/order/test",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn sor_order(
        &self,
        params: SorOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::SorOrderResponse>> {
        let SorOrderParams {
            symbol,
            side,
            r#type,
            quantity,
            time_in_force,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        let quantity_value = Decimal::from_f32(quantity).unwrap_or_default();
        query_params.insert("quantity".to_string(), json!(quantity_value));

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_type {
            query_params.insert("strategyType".to_string(), json!(rw));
        }

        if let Some(rw) = iceberg_qty {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("icebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::SorOrderResponse>(
            &self.configuration,
            "/api/v3/sor/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn sor_order_test(
        &self,
        params: SorOrderTestParams,
    ) -> anyhow::Result<RestApiResponse<models::SorOrderTestResponse>> {
        let SorOrderTestParams {
            compute_commission_rates,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = compute_commission_rates {
            query_params.insert("computeCommissionRates".to_string(), json!(rw));
        }

        send_request::<models::SorOrderTestResponse>(
            &self.configuration,
            "/api/v3/sor/order/test",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "spot"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockTradeApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl TradeApi for MockTradeApiClient {
        async fn delete_open_orders(
            &self,
            _params: DeleteOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::DeleteOpenOrdersResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350068,"price":"0.089853","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"A3EF2HCwxgZPFMrfwbgrhv","orderId":13,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350069,"price":"0.090430","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.668611","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.008791","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962","selfTradePreventionMode":"NONE"}]}]"#).unwrap();
            let dummy_response: Vec<models::DeleteOpenOrdersResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::DeleteOpenOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn delete_order(
            &self,
            _params: DeleteOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::DeleteOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","origClientOrderId":"myOrder1","orderId":4,"orderListId":-1,"clientOrderId":"cancelMyOrder1","transactTime":1684804350068,"price":"2.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"}"#).unwrap();
            let dummy_response: models::DeleteOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DeleteOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn delete_order_list(
            &self,
            _params: DeleteOrderListParams,
        ) -> anyhow::Result<RestApiResponse<models::DeleteOrderListResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let dummy_response: models::DeleteOrderListResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DeleteOrderListResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_order(
            &self,
            _params: NewOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"orderListId":-1,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"0.00000000","origQty":"10.00000000","executedQty":"10.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","workingTime":1507725176595,"selfTradePreventionMode":"NONE","fills":[{"price":"3995.00000000","qty":"1.00000000","commission":"3.99500000","commissionAsset":"USDT","tradeId":60},{"price":"3997.00000000","qty":"1.00000000","commission":"3.99700000","commissionAsset":"USDT","tradeId":59},{"price":"3998.00000000","qty":"2.00000000","commission":"7.99600000","commissionAsset":"USDT","tradeId":58},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT","tradeId":57},{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT","tradeId":56}]}"#).unwrap();
            let dummy_response: models::NewOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_amend_keep_priority(
            &self,
            _params: OrderAmendKeepPriorityParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderAmendKeepPriorityResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"transactTime":1741669661670,"executionId":22,"amendedOrder":{"symbol":"BTCUSDT","orderId":9,"orderListId":1,"origClientOrderId":"W0fJ9fiLKHOJutovPK3oJp","clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi","price":"0.00000000","qty":"4.00000000","executedQty":"0.00000000","preventedQty":"0.00000000","quoteOrderQty":"0.00000000","cumulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":1741926410242,"selfTradePreventionMode":"NONE"},"listStatus":{"orderListId":1,"contingencyType":"OTO","listOrderStatus":"EXECUTING","listClientOrderId":"AT7FTxZXylVSwRoZs52mt3","symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"},{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"}]}}"#).unwrap();
            let dummy_response: models::OrderAmendKeepPriorityResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderAmendKeepPriorityResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_cancel_replace(
            &self,
            _params: OrderCancelReplaceParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderCancelReplaceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":-2021,"msg":"Order cancel-replace partially failed.","data":{"cancelResult":"SUCCESS","newOrderResult":"FAILURE","cancelResponse":{"symbol":"LTCBNB","origClientOrderId":"GKt5zzfOxRDSQLveDYCTkc","orderId":64,"orderListId":-1,"clientOrderId":"loehOJF3FjoreUBDmv739R","transactTime":1715779007228,"price":"1.00","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","selfTradePreventionMode":"NONE"},"newOrderResponse":{"code":-1015,"msg":"Too many new orders; current limit is 1 orders per 10 SECOND."}}}"#).unwrap();
            let dummy_response: models::OrderCancelReplaceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderCancelReplaceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_list_oco(
            &self,
            _params: OrderListOcoParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderListOcoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"lH1YDkuQKWiXVXHPSKYEIp","transactionTime":1710485608839,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":11,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK"},{"symbol":"LTCBTC","orderId":10,"clientOrderId":"44nZvqpemY7sVYgPYbvPih"}],"orderReports":[{"symbol":"LTCBTC","orderId":11,"orderListId":1,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK","transactTime":1710485608839,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","workingTime":1710485608839,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":10,"orderListId":1,"clientOrderId":"44nZvqpemY7sVYgPYbvPih","transactTime":1710485608839,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","workingTime":-1,"icebergQty":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let dummy_response: models::OrderListOcoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderListOcoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_list_oto(
            &self,
            _params: OrderListOtoParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderListOtoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"yl2ERtcar1o25zcWtqVBTC","transactionTime":1712289389158,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":5,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d"},{"symbol":"LTCBTC","orderId":4,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya"}],"orderReports":[{"symbol":"LTCBTC","orderId":5,"orderListId":0,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d","transactTime":1712289389158,"price":"0.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":4,"orderListId":0,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya","transactTime":1712289389158,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712289389158,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let dummy_response: models::OrderListOtoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderListOtoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_list_otoco(
            &self,
            _params: OrderListOtocoParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderListOtocoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"RumwQpBaDctlUu5jyG5rs0","transactionTime":1712291372842,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":8,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx"},{"symbol":"LTCBTC","orderId":7,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4"},{"symbol":"LTCBTC","orderId":6,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK"}],"orderReports":[{"symbol":"LTCBTC","orderId":8,"orderListId":1,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx","transactTime":1712291372842,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":7,"orderListId":1,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4","transactTime":1712291372842,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"IOC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"6.00000000","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":6,"orderListId":1,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK","transactTime":1712291372842,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712291372842,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let dummy_response: models::OrderListOtocoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderListOtocoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_oco(
            &self,
            _params: OrderOcoParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderOcoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"}],"orderReports":[{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":1563417480525,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664","workingTime":-1,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let dummy_response: models::OrderOcoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderOcoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_test(
            &self,
            _params: OrderTestParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderTestResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let dummy_response: models::OrderTestResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderTestResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn sor_order(
            &self,
            _params: SorOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::SorOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":2,"orderListId":-1,"clientOrderId":"sBI1KM6nNtOfj5tccZSKly","transactTime":1689149087774,"price":"31000.00000000","origQty":"0.50000000","executedQty":"0.50000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"14000.00000000","status":"FILLED","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1689149087774,"fills":[{"matchType":"ONE_PARTY_TRADE_REPORT","price":"28000.00000000","qty":"0.50000000","commission":"0.00000000","commissionAsset":"BTC","tradeId":-1,"allocId":0}],"workingFloor":"SOR","selfTradePreventionMode":"NONE","usedSor":true}"#).unwrap();
            let dummy_response: models::SorOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SorOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn sor_order_test(
            &self,
            _params: SorOrderTestParams,
        ) -> anyhow::Result<RestApiResponse<models::SorOrderTestResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let dummy_response: models::SorOrderTestResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SorOrderTestResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn delete_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOpenOrdersParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350068,"price":"0.089853","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"A3EF2HCwxgZPFMrfwbgrhv","orderId":13,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350069,"price":"0.090430","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.668611","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.008791","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962","selfTradePreventionMode":"NONE"}]}]"#).unwrap();
            let expected_response : Vec<models::DeleteOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::DeleteOpenOrdersResponseInner>");

            let resp = client.delete_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOpenOrdersParams::builder("BNBUSDT".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350068,"price":"0.089853","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"A3EF2HCwxgZPFMrfwbgrhv","orderId":13,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1684804350069,"price":"0.090430","origQty":"0.178622","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.668611","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","transactTime":1688005070874,"price":"0.008791","origQty":"0.690354","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962","selfTradePreventionMode":"NONE"}]}]"#).unwrap();
            let expected_response : Vec<models::DeleteOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::DeleteOpenOrdersResponseInner>");

            let resp = client.delete_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = DeleteOpenOrdersParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.delete_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn delete_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOrderParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","origClientOrderId":"myOrder1","orderId":4,"orderListId":-1,"clientOrderId":"cancelMyOrder1","transactTime":1684804350068,"price":"2.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"}"#).unwrap();
            let expected_response : models::DeleteOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteOrderResponse");

            let resp = client.delete_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOrderParams::builder("BNBUSDT".to_string(),).order_id(1).orig_client_order_id("orig_client_order_id_example".to_string()).new_client_order_id("new_client_order_id_example".to_string()).cancel_restrictions(DeleteOrderCancelRestrictionsEnum::OnlyNew).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","origClientOrderId":"myOrder1","orderId":4,"orderListId":-1,"clientOrderId":"cancelMyOrder1","transactTime":1684804350068,"price":"2.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY","selfTradePreventionMode":"NONE"}"#).unwrap();
            let expected_response : models::DeleteOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteOrderResponse");

            let resp = client.delete_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = DeleteOrderParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.delete_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn delete_order_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOrderListParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::DeleteOrderListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteOrderListResponse");

            let resp = client.delete_order_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_order_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = DeleteOrderListParams::builder("BNBUSDT".to_string(),).order_list_id(1).list_client_order_id("list_client_order_id_example".to_string()).new_client_order_id("new_client_order_id_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","transactTime":1688005070874,"price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::DeleteOrderListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DeleteOrderListResponse");

            let resp = client.delete_order_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn delete_order_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = DeleteOrderListParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.delete_order_list(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewOrderParams::builder("BNBUSDT".to_string(),NewOrderSideEnum::Buy,NewOrderTypeEnum::Market,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"orderListId":-1,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"0.00000000","origQty":"10.00000000","executedQty":"10.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","workingTime":1507725176595,"selfTradePreventionMode":"NONE","fills":[{"price":"3995.00000000","qty":"1.00000000","commission":"3.99500000","commissionAsset":"USDT","tradeId":60},{"price":"3997.00000000","qty":"1.00000000","commission":"3.99700000","commissionAsset":"USDT","tradeId":59},{"price":"3998.00000000","qty":"2.00000000","commission":"7.99600000","commissionAsset":"USDT","tradeId":58},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT","tradeId":57},{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT","tradeId":56}]}"#).unwrap();
            let expected_response : models::NewOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewOrderResponse");

            let resp = client.new_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewOrderParams::builder("BNBUSDT".to_string(),NewOrderSideEnum::Buy,NewOrderTypeEnum::Market,).time_in_force(NewOrderTimeInForceEnum::Gtc).quantity(1.0).quote_order_qty(1.0).price(400.0).new_client_order_id("new_client_order_id_example".to_string()).strategy_id(1).strategy_type(1).stop_price(1.0).trailing_delta(1).iceberg_qty(1.0).new_order_resp_type(NewOrderNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(NewOrderSelfTradePreventionModeEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"orderListId":-1,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"0.00000000","origQty":"10.00000000","executedQty":"10.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","workingTime":1507725176595,"selfTradePreventionMode":"NONE","fills":[{"price":"3995.00000000","qty":"1.00000000","commission":"3.99500000","commissionAsset":"USDT","tradeId":60},{"price":"3997.00000000","qty":"1.00000000","commission":"3.99700000","commissionAsset":"USDT","tradeId":59},{"price":"3998.00000000","qty":"2.00000000","commission":"7.99600000","commissionAsset":"USDT","tradeId":58},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT","tradeId":57},{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT","tradeId":56}]}"#).unwrap();
            let expected_response : models::NewOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewOrderResponse");

            let resp = client.new_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewOrderParams::builder(
                "BNBUSDT".to_string(),
                NewOrderSideEnum::Buy,
                NewOrderTypeEnum::Market,
            )
            .build()
            .unwrap();

            match client.new_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_amend_keep_priority_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(),1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"transactTime":1741669661670,"executionId":22,"amendedOrder":{"symbol":"BTCUSDT","orderId":9,"orderListId":1,"origClientOrderId":"W0fJ9fiLKHOJutovPK3oJp","clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi","price":"0.00000000","qty":"4.00000000","executedQty":"0.00000000","preventedQty":"0.00000000","quoteOrderQty":"0.00000000","cumulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":1741926410242,"selfTradePreventionMode":"NONE"},"listStatus":{"orderListId":1,"contingencyType":"OTO","listOrderStatus":"EXECUTING","listClientOrderId":"AT7FTxZXylVSwRoZs52mt3","symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"},{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"}]}}"#).unwrap();
            let expected_response : models::OrderAmendKeepPriorityResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderAmendKeepPriorityResponse");

            let resp = client.order_amend_keep_priority(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_amend_keep_priority_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(),1.0,).order_id(1).orig_client_order_id("orig_client_order_id_example".to_string()).new_client_order_id("new_client_order_id_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"transactTime":1741669661670,"executionId":22,"amendedOrder":{"symbol":"BTCUSDT","orderId":9,"orderListId":1,"origClientOrderId":"W0fJ9fiLKHOJutovPK3oJp","clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi","price":"0.00000000","qty":"4.00000000","executedQty":"0.00000000","preventedQty":"0.00000000","quoteOrderQty":"0.00000000","cumulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":1741926410242,"selfTradePreventionMode":"NONE"},"listStatus":{"orderListId":1,"contingencyType":"OTO","listOrderStatus":"EXECUTING","listClientOrderId":"AT7FTxZXylVSwRoZs52mt3","symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"},{"symbol":"BTCUSDT","orderId":9,"clientOrderId":"UQ1Np3bmQ71jJzsSDW9Vpi"},{"symbol":"BTCUSDT","orderId":8,"clientOrderId":"GkwwHZUUbFtZOoH1YsZk9Q"}]}}"#).unwrap();
            let expected_response : models::OrderAmendKeepPriorityResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderAmendKeepPriorityResponse");

            let resp = client.order_amend_keep_priority(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_amend_keep_priority_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(), 1.0)
                .build()
                .unwrap();

            match client.order_amend_keep_priority(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_cancel_replace_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderCancelReplaceParams::builder("BNBUSDT".to_string(),OrderCancelReplaceSideEnum::Buy,OrderCancelReplaceTypeEnum::Market,OrderCancelReplaceCancelReplaceModeEnum::StopOnFailure,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":-2021,"msg":"Order cancel-replace partially failed.","data":{"cancelResult":"SUCCESS","newOrderResult":"FAILURE","cancelResponse":{"symbol":"LTCBNB","origClientOrderId":"GKt5zzfOxRDSQLveDYCTkc","orderId":64,"orderListId":-1,"clientOrderId":"loehOJF3FjoreUBDmv739R","transactTime":1715779007228,"price":"1.00","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","selfTradePreventionMode":"NONE"},"newOrderResponse":{"code":-1015,"msg":"Too many new orders; current limit is 1 orders per 10 SECOND."}}}"#).unwrap();
            let expected_response : models::OrderCancelReplaceResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderCancelReplaceResponse");

            let resp = client.order_cancel_replace(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_cancel_replace_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderCancelReplaceParams::builder("BNBUSDT".to_string(),OrderCancelReplaceSideEnum::Buy,OrderCancelReplaceTypeEnum::Market,OrderCancelReplaceCancelReplaceModeEnum::StopOnFailure,).time_in_force(OrderCancelReplaceTimeInForceEnum::Gtc).quantity(1.0).quote_order_qty(1.0).price(400.0).cancel_new_client_order_id("cancel_new_client_order_id_example".to_string()).cancel_orig_client_order_id("cancel_orig_client_order_id_example".to_string()).cancel_order_id(1).new_client_order_id("new_client_order_id_example".to_string()).strategy_id(1).strategy_type(1).stop_price(1.0).trailing_delta(1).iceberg_qty(1.0).new_order_resp_type(OrderCancelReplaceNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(OrderCancelReplaceSelfTradePreventionModeEnum::None).cancel_restrictions(OrderCancelReplaceCancelRestrictionsEnum::OnlyNew).order_rate_limit_exceeded_mode(OrderCancelReplaceOrderRateLimitExceededModeEnum::DoNothing).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":-2021,"msg":"Order cancel-replace partially failed.","data":{"cancelResult":"SUCCESS","newOrderResult":"FAILURE","cancelResponse":{"symbol":"LTCBNB","origClientOrderId":"GKt5zzfOxRDSQLveDYCTkc","orderId":64,"orderListId":-1,"clientOrderId":"loehOJF3FjoreUBDmv739R","transactTime":1715779007228,"price":"1.00","origQty":"10.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","selfTradePreventionMode":"NONE"},"newOrderResponse":{"code":-1015,"msg":"Too many new orders; current limit is 1 orders per 10 SECOND."}}}"#).unwrap();
            let expected_response : models::OrderCancelReplaceResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderCancelReplaceResponse");

            let resp = client.order_cancel_replace(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_cancel_replace_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderCancelReplaceParams::builder(
                "BNBUSDT".to_string(),
                OrderCancelReplaceSideEnum::Buy,
                OrderCancelReplaceTypeEnum::Market,
                OrderCancelReplaceCancelReplaceModeEnum::StopOnFailure,
            )
            .build()
            .unwrap();

            match client.order_cancel_replace(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_list_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOcoParams::builder("BNBUSDT".to_string(),OrderListOcoSideEnum::Buy,1.0,OrderListOcoAboveTypeEnum::StopLossLimit,OrderListOcoBelowTypeEnum::StopLoss,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"lH1YDkuQKWiXVXHPSKYEIp","transactionTime":1710485608839,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":11,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK"},{"symbol":"LTCBTC","orderId":10,"clientOrderId":"44nZvqpemY7sVYgPYbvPih"}],"orderReports":[{"symbol":"LTCBTC","orderId":11,"orderListId":1,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK","transactTime":1710485608839,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","workingTime":1710485608839,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":10,"orderListId":1,"clientOrderId":"44nZvqpemY7sVYgPYbvPih","transactTime":1710485608839,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","workingTime":-1,"icebergQty":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOcoResponse");

            let resp = client.order_list_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOcoParams::builder("BNBUSDT".to_string(),OrderListOcoSideEnum::Buy,1.0,OrderListOcoAboveTypeEnum::StopLossLimit,OrderListOcoBelowTypeEnum::StopLoss,).list_client_order_id("list_client_order_id_example".to_string()).above_client_order_id("above_client_order_id_example".to_string()).above_iceberg_qty(1).above_price(1.0).above_stop_price(1.0).above_trailing_delta(1).above_time_in_force(1.0).above_strategy_id(1).above_strategy_type(1).below_client_order_id("below_client_order_id_example".to_string()).below_iceberg_qty(1).below_price(1.0).below_stop_price(1.0).below_trailing_delta(1).below_time_in_force(OrderListOcoBelowTimeInForceEnum::Belowtype).below_strategy_id(1).below_strategy_type(1).new_order_resp_type(OrderListOcoNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(OrderListOcoSelfTradePreventionModeEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"lH1YDkuQKWiXVXHPSKYEIp","transactionTime":1710485608839,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":11,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK"},{"symbol":"LTCBTC","orderId":10,"clientOrderId":"44nZvqpemY7sVYgPYbvPih"}],"orderReports":[{"symbol":"LTCBTC","orderId":11,"orderListId":1,"clientOrderId":"NuMp0nVYnciDiFmVqfpBqK","transactTime":1710485608839,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","workingTime":1710485608839,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":10,"orderListId":1,"clientOrderId":"44nZvqpemY7sVYgPYbvPih","transactTime":1710485608839,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000","workingTime":-1,"icebergQty":"1.00000000","selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOcoResponse");

            let resp = client.order_list_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderListOcoParams::builder(
                "BNBUSDT".to_string(),
                OrderListOcoSideEnum::Buy,
                1.0,
                OrderListOcoAboveTypeEnum::StopLossLimit,
                OrderListOcoBelowTypeEnum::StopLoss,
            )
            .build()
            .unwrap();

            match client.order_list_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_list_oto_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOtoParams::builder("BNBUSDT".to_string(),OrderListOtoWorkingTypeEnum::Limit,OrderListOtoWorkingSideEnum::Buy,1.0,1.0,OrderListOtoPendingTypeEnum::Limit,OrderListOtoPendingSideEnum::Buy,1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"yl2ERtcar1o25zcWtqVBTC","transactionTime":1712289389158,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":5,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d"},{"symbol":"LTCBTC","orderId":4,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya"}],"orderReports":[{"symbol":"LTCBTC","orderId":5,"orderListId":0,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d","transactTime":1712289389158,"price":"0.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":4,"orderListId":0,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya","transactTime":1712289389158,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712289389158,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOtoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOtoResponse");

            let resp = client.order_list_oto(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_oto_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOtoParams::builder("BNBUSDT".to_string(),OrderListOtoWorkingTypeEnum::Limit,OrderListOtoWorkingSideEnum::Buy,1.0,1.0,OrderListOtoPendingTypeEnum::Limit,OrderListOtoPendingSideEnum::Buy,1.0,).list_client_order_id("list_client_order_id_example".to_string()).new_order_resp_type(OrderListOtoNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(OrderListOtoSelfTradePreventionModeEnum::None).working_client_order_id("working_client_order_id_example".to_string()).working_iceberg_qty(1.0).working_time_in_force(OrderListOtoWorkingTimeInForceEnum::Gtc).working_strategy_id(1).working_strategy_type(1).pending_client_order_id("pending_client_order_id_example".to_string()).pending_price(1.0).pending_stop_price(1.0).pending_trailing_delta(1.0).pending_iceberg_qty(1.0).pending_time_in_force(OrderListOtoPendingTimeInForceEnum::Gtc).pending_strategy_id(1).pending_strategy_type(1).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"yl2ERtcar1o25zcWtqVBTC","transactionTime":1712289389158,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":5,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d"},{"symbol":"LTCBTC","orderId":4,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya"}],"orderReports":[{"symbol":"LTCBTC","orderId":5,"orderListId":0,"clientOrderId":"arLFo0zGJVDE69cvGBaU0d","transactTime":1712289389158,"price":"0.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":4,"orderListId":0,"clientOrderId":"Bq17mn9fP6vyCn75Jw1xya","transactTime":1712289389158,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712289389158,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOtoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOtoResponse");

            let resp = client.order_list_oto(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_oto_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderListOtoParams::builder(
                "BNBUSDT".to_string(),
                OrderListOtoWorkingTypeEnum::Limit,
                OrderListOtoWorkingSideEnum::Buy,
                1.0,
                1.0,
                OrderListOtoPendingTypeEnum::Limit,
                OrderListOtoPendingSideEnum::Buy,
                1.0,
            )
            .build()
            .unwrap();

            match client.order_list_oto(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_list_otoco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOtocoParams::builder("BNBUSDT".to_string(),OrderListOtocoWorkingTypeEnum::Limit,OrderListOtocoWorkingSideEnum::Buy,1.0,1.0,OrderListOtocoPendingSideEnum::Buy,1.0,OrderListOtocoPendingAboveTypeEnum::StopLossLimit,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"RumwQpBaDctlUu5jyG5rs0","transactionTime":1712291372842,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":8,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx"},{"symbol":"LTCBTC","orderId":7,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4"},{"symbol":"LTCBTC","orderId":6,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK"}],"orderReports":[{"symbol":"LTCBTC","orderId":8,"orderListId":1,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx","transactTime":1712291372842,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":7,"orderListId":1,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4","transactTime":1712291372842,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"IOC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"6.00000000","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":6,"orderListId":1,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK","transactTime":1712291372842,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712291372842,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOtocoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOtocoResponse");

            let resp = client.order_list_otoco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_otoco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderListOtocoParams::builder("BNBUSDT".to_string(),OrderListOtocoWorkingTypeEnum::Limit,OrderListOtocoWorkingSideEnum::Buy,1.0,1.0,OrderListOtocoPendingSideEnum::Buy,1.0,OrderListOtocoPendingAboveTypeEnum::StopLossLimit,).list_client_order_id("list_client_order_id_example".to_string()).new_order_resp_type(OrderListOtocoNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(OrderListOtocoSelfTradePreventionModeEnum::None).working_client_order_id("working_client_order_id_example".to_string()).working_iceberg_qty(1.0).working_time_in_force(OrderListOtocoWorkingTimeInForceEnum::Gtc).working_strategy_id(1).working_strategy_type(1).pending_above_client_order_id("pending_above_client_order_id_example".to_string()).pending_above_price(1.0).pending_above_stop_price(1.0).pending_above_trailing_delta(1.0).pending_above_iceberg_qty(1.0).pending_above_time_in_force(OrderListOtocoPendingAboveTimeInForceEnum::Gtc).pending_above_strategy_id(1).pending_above_strategy_type(1).pending_below_type(OrderListOtocoPendingBelowTypeEnum::StopLoss).pending_below_client_order_id("pending_below_client_order_id_example".to_string()).pending_below_price(1.0).pending_below_stop_price(1.0).pending_below_trailing_delta(1.0).pending_below_iceberg_qty(1.0).pending_below_time_in_force(OrderListOtocoPendingBelowTimeInForceEnum::Gtc).pending_below_strategy_id(1).pending_below_strategy_type(1).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":1,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"RumwQpBaDctlUu5jyG5rs0","transactionTime":1712291372842,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":8,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx"},{"symbol":"LTCBTC","orderId":7,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4"},{"symbol":"LTCBTC","orderId":6,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK"}],"orderReports":[{"symbol":"LTCBTC","orderId":8,"orderListId":1,"clientOrderId":"r4JMv9cwAYYUwwBZfbussx","transactTime":1712291372842,"price":"3.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":7,"orderListId":1,"clientOrderId":"6pcQbFIzTXGZQ1e2MkGDq4","transactTime":1712291372842,"price":"1.00000000","origQty":"5.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"PENDING_NEW","timeInForce":"IOC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"6.00000000","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":6,"orderListId":1,"clientOrderId":"fM9Y4m23IFJVCQmIrlUmMK","transactTime":1712291372842,"price":"1.00000000","origQty":"1.00000000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712291372842,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderListOtocoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderListOtocoResponse");

            let resp = client.order_list_otoco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_list_otoco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderListOtocoParams::builder(
                "BNBUSDT".to_string(),
                OrderListOtocoWorkingTypeEnum::Limit,
                OrderListOtocoWorkingSideEnum::Buy,
                1.0,
                1.0,
                OrderListOtocoPendingSideEnum::Buy,
                1.0,
                OrderListOtocoPendingAboveTypeEnum::StopLossLimit,
            )
            .build()
            .unwrap();

            match client.order_list_otoco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderOcoParams::builder("BNBUSDT".to_string(),OrderOcoSideEnum::Buy,1.0,1.0,1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"}],"orderReports":[{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":1563417480525,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664","workingTime":-1,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderOcoResponse");

            let resp = client.order_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderOcoParams::builder("BNBUSDT".to_string(),OrderOcoSideEnum::Buy,1.0,1.0,1.0,).list_client_order_id("list_client_order_id_example".to_string()).limit_client_order_id("limit_client_order_id_example".to_string()).limit_strategy_id(1).limit_strategy_type(1).limit_iceberg_qty(1.0).trailing_delta(1).stop_client_order_id("stop_client_order_id_example".to_string()).stop_strategy_id(1).stop_strategy_type(1).stop_limit_price(1.0).stop_iceberg_qty(1.0).stop_limit_time_in_force(OrderOcoStopLimitTimeInForceEnum::Gtc).new_order_resp_type(OrderOcoNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(OrderOcoSelfTradePreventionModeEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"},{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"}],"orderReports":[{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":1563417480525,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664","workingTime":-1,"selfTradePreventionMode":"NONE"}]}"#).unwrap();
            let expected_response : models::OrderOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderOcoResponse");

            let resp = client.order_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderOcoParams::builder(
                "BNBUSDT".to_string(),
                OrderOcoSideEnum::Buy,
                1.0,
                1.0,
                1.0,
            )
            .build()
            .unwrap();

            match client.order_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_test_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderTestParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let expected_response : models::OrderTestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderTestResponse");

            let resp = client.order_test(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_test_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderTestParams::builder().compute_commission_rates(false).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let expected_response : models::OrderTestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderTestResponse");

            let resp = client.order_test(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_test_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderTestParams::builder().build().unwrap();

            match client.order_test(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn sor_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SorOrderParams::builder("BNBUSDT".to_string(),SorOrderSideEnum::Buy,SorOrderTypeEnum::Market,1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":2,"orderListId":-1,"clientOrderId":"sBI1KM6nNtOfj5tccZSKly","transactTime":1689149087774,"price":"31000.00000000","origQty":"0.50000000","executedQty":"0.50000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"14000.00000000","status":"FILLED","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1689149087774,"fills":[{"matchType":"ONE_PARTY_TRADE_REPORT","price":"28000.00000000","qty":"0.50000000","commission":"0.00000000","commissionAsset":"BTC","tradeId":-1,"allocId":0}],"workingFloor":"SOR","selfTradePreventionMode":"NONE","usedSor":true}"#).unwrap();
            let expected_response : models::SorOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SorOrderResponse");

            let resp = client.sor_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sor_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SorOrderParams::builder("BNBUSDT".to_string(),SorOrderSideEnum::Buy,SorOrderTypeEnum::Market,1.0,).time_in_force(SorOrderTimeInForceEnum::Gtc).price(400.0).new_client_order_id("new_client_order_id_example".to_string()).strategy_id(1).strategy_type(1).iceberg_qty(1.0).new_order_resp_type(SorOrderNewOrderRespTypeEnum::Ack).self_trade_prevention_mode(SorOrderSelfTradePreventionModeEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":2,"orderListId":-1,"clientOrderId":"sBI1KM6nNtOfj5tccZSKly","transactTime":1689149087774,"price":"31000.00000000","origQty":"0.50000000","executedQty":"0.50000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"14000.00000000","status":"FILLED","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1689149087774,"fills":[{"matchType":"ONE_PARTY_TRADE_REPORT","price":"28000.00000000","qty":"0.50000000","commission":"0.00000000","commissionAsset":"BTC","tradeId":-1,"allocId":0}],"workingFloor":"SOR","selfTradePreventionMode":"NONE","usedSor":true}"#).unwrap();
            let expected_response : models::SorOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SorOrderResponse");

            let resp = client.sor_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sor_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = SorOrderParams::builder(
                "BNBUSDT".to_string(),
                SorOrderSideEnum::Buy,
                SorOrderTypeEnum::Market,
                1.0,
            )
            .build()
            .unwrap();

            match client.sor_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn sor_order_test_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SorOrderTestParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let expected_response : models::SorOrderTestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SorOrderTestResponse");

            let resp = client.sor_order_test(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sor_order_test_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SorOrderTestParams::builder().compute_commission_rates(false).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}}"#).unwrap();
            let expected_response : models::SorOrderTestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SorOrderTestResponse");

            let resp = client.sor_order_test(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sor_order_test_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = SorOrderTestParams::builder().build().unwrap();

            match client.sor_order_test(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
