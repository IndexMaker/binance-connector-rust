/*
 * Binance Derivatives Trading Options REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::derivatives_trading_options::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountApi: Send + Sync {
    async fn account_funding_flow(
        &self,
        params: AccountFundingFlowParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AccountFundingFlowResponseInner>>>;
    async fn get_download_id_for_option_transaction_history(
        &self,
        params: GetDownloadIdForOptionTransactionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForOptionTransactionHistoryResponse>>;
    async fn get_option_transaction_history_download_link_by_id(
        &self,
        params: GetOptionTransactionHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetOptionTransactionHistoryDownloadLinkByIdResponse>>;
    async fn option_account_information(
        &self,
        params: OptionAccountInformationParams,
    ) -> anyhow::Result<RestApiResponse<models::OptionAccountInformationResponse>>;
}

#[derive(Debug, Clone)]
pub struct AccountApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`account_funding_flow`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`account_funding_flow`](#method.account_funding_flow).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AccountFundingFlowParams {
    /// Asset type, only support USDT  as of now
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub currency: String,
    /// Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub record_id: Option<i64>,
    /// Start Time, e.g 1593511200000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// End Time, e.g 1593512200000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Number of result sets returned Default:100 Max:1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AccountFundingFlowParams {
    /// Create a builder for [`account_funding_flow`].
    ///
    /// Required parameters:
    ///
    /// * `currency` — Asset type, only support USDT  as of now
    ///
    #[must_use]
    pub fn builder(currency: String) -> AccountFundingFlowParamsBuilder {
        AccountFundingFlowParamsBuilder::default().currency(currency)
    }
}
/// Request parameters for the [`get_download_id_for_option_transaction_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_download_id_for_option_transaction_history`](#method.get_download_id_for_option_transaction_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetDownloadIdForOptionTransactionHistoryParams {
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub start_time: i64,
    /// Timestamp in ms
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub end_time: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetDownloadIdForOptionTransactionHistoryParams {
    /// Create a builder for [`get_download_id_for_option_transaction_history`].
    ///
    /// Required parameters:
    ///
    /// * `start_time` — Timestamp in ms
    /// * `end_time` — Timestamp in ms
    ///
    #[must_use]
    pub fn builder(
        start_time: i64,
        end_time: i64,
    ) -> GetDownloadIdForOptionTransactionHistoryParamsBuilder {
        GetDownloadIdForOptionTransactionHistoryParamsBuilder::default()
            .start_time(start_time)
            .end_time(end_time)
    }
}
/// Request parameters for the [`get_option_transaction_history_download_link_by_id`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_option_transaction_history_download_link_by_id`](#method.get_option_transaction_history_download_link_by_id).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetOptionTransactionHistoryDownloadLinkByIdParams {
    /// get by download id api
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub download_id: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetOptionTransactionHistoryDownloadLinkByIdParams {
    /// Create a builder for [`get_option_transaction_history_download_link_by_id`].
    ///
    /// Required parameters:
    ///
    /// * `download_id` — get by download id api
    ///
    #[must_use]
    pub fn builder(
        download_id: String,
    ) -> GetOptionTransactionHistoryDownloadLinkByIdParamsBuilder {
        GetOptionTransactionHistoryDownloadLinkByIdParamsBuilder::default().download_id(download_id)
    }
}
/// Request parameters for the [`option_account_information`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`option_account_information`](#method.option_account_information).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OptionAccountInformationParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OptionAccountInformationParams {
    /// Create a builder for [`option_account_information`].
    ///
    #[must_use]
    pub fn builder() -> OptionAccountInformationParamsBuilder {
        OptionAccountInformationParamsBuilder::default()
    }
}

#[async_trait]
impl AccountApi for AccountApiClient {
    async fn account_funding_flow(
        &self,
        params: AccountFundingFlowParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AccountFundingFlowResponseInner>>> {
        let AccountFundingFlowParams {
            currency,
            record_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("currency".to_string(), json!(currency));

        if let Some(rw) = record_id {
            query_params.insert("recordId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::AccountFundingFlowResponseInner>>(
            &self.configuration,
            "/eapi/v1/bill",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_download_id_for_option_transaction_history(
        &self,
        params: GetDownloadIdForOptionTransactionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForOptionTransactionHistoryResponse>>
    {
        let GetDownloadIdForOptionTransactionHistoryParams {
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("startTime".to_string(), json!(start_time));

        query_params.insert("endTime".to_string(), json!(end_time));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetDownloadIdForOptionTransactionHistoryResponse>(
            &self.configuration,
            "/eapi/v1/income/asyn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_option_transaction_history_download_link_by_id(
        &self,
        params: GetOptionTransactionHistoryDownloadLinkByIdParams,
    ) -> anyhow::Result<RestApiResponse<models::GetOptionTransactionHistoryDownloadLinkByIdResponse>>
    {
        let GetOptionTransactionHistoryDownloadLinkByIdParams {
            download_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("downloadId".to_string(), json!(download_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetOptionTransactionHistoryDownloadLinkByIdResponse>(
            &self.configuration,
            "/eapi/v1/income/asyn/id",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn option_account_information(
        &self,
        params: OptionAccountInformationParams,
    ) -> anyhow::Result<RestApiResponse<models::OptionAccountInformationResponse>> {
        let OptionAccountInformationParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::OptionAccountInformationResponse>(
            &self.configuration,
            "/eapi/v1/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "derivatives_trading_options"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountApi for MockAccountApiClient {
        async fn account_funding_flow(
            &self,
            _params: AccountFundingFlowParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::AccountFundingFlowResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":1125899906842624000,"asset":"USDT","amount":"-0.552","type":"FEE","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"100","type":"CONTRACT","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"10000","type":"TRANSFER","createDate":1592448410000}]"#).unwrap();
            let dummy_response: Vec<models::AccountFundingFlowResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::AccountFundingFlowResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_download_id_for_option_transaction_history(
            &self,
            _params: GetDownloadIdForOptionTransactionHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetDownloadIdForOptionTransactionHistoryResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let dummy_response: models::GetDownloadIdForOptionTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForOptionTransactionHistoryResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_option_transaction_history_download_link_by_id(
            &self,
            _params: GetOptionTransactionHistoryDownloadLinkByIdParams,
        ) -> anyhow::Result<
            RestApiResponse<models::GetOptionTransactionHistoryDownloadLinkByIdResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let dummy_response: models::GetOptionTransactionHistoryDownloadLinkByIdResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetOptionTransactionHistoryDownloadLinkByIdResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn option_account_information(
            &self,
            _params: OptionAccountInformationParams,
        ) -> anyhow::Result<RestApiResponse<models::OptionAccountInformationResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"asset":[{"asset":"USDT","marginBalance":"1877.52214415","equity":"617.77711415","available":"0","locked":"2898.92389933","unrealizedPNL":"222.23697000"}],"greek":[{"underlying":"BTCUSDT","delta":"-0.05","gamma":"-0.002","theta":"-0.05","vega":"-0.002"}],"time":1592449455993,"riskLevel":"NORMAL"}"#).unwrap();
            let dummy_response: models::OptionAccountInformationResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OptionAccountInformationResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn account_funding_flow_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountFundingFlowParams::builder("currency_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":1125899906842624000,"asset":"USDT","amount":"-0.552","type":"FEE","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"100","type":"CONTRACT","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"10000","type":"TRANSFER","createDate":1592448410000}]"#).unwrap();
            let expected_response : Vec<models::AccountFundingFlowResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AccountFundingFlowResponseInner>");

            let resp = client.account_funding_flow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_funding_flow_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AccountFundingFlowParams::builder("currency_example".to_string(),).record_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":1125899906842624000,"asset":"USDT","amount":"-0.552","type":"FEE","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"100","type":"CONTRACT","createDate":1592449456000},{"id":1125899906842624000,"asset":"USDT","amount":"10000","type":"TRANSFER","createDate":1592448410000}]"#).unwrap();
            let expected_response : Vec<models::AccountFundingFlowResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AccountFundingFlowResponseInner>");

            let resp = client.account_funding_flow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn account_funding_flow_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AccountFundingFlowParams::builder("currency_example".to_string())
                .build()
                .unwrap();

            match client.account_funding_flow(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_download_id_for_option_transaction_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetDownloadIdForOptionTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForOptionTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForOptionTransactionHistoryResponse",
                );

            let resp = client
                .get_download_id_for_option_transaction_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_option_transaction_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetDownloadIdForOptionTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"avgCostTimestampOfLast30d":7241837,"downloadId":"546975389218332672"}"#,
            )
            .unwrap();
            let expected_response: models::GetDownloadIdForOptionTransactionHistoryResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetDownloadIdForOptionTransactionHistoryResponse",
                );

            let resp = client
                .get_download_id_for_option_transaction_history(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_download_id_for_option_transaction_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetDownloadIdForOptionTransactionHistoryParams::builder(
                1623319461670,
                1641782889000,
            )
            .build()
            .unwrap();

            match client
                .get_download_id_for_option_transaction_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_option_transaction_history_download_link_by_id_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetOptionTransactionHistoryDownloadLinkByIdParams::builder("1".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetOptionTransactionHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetOptionTransactionHistoryDownloadLinkByIdResponse");

            let resp = client.get_option_transaction_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_option_transaction_history_download_link_by_id_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetOptionTransactionHistoryDownloadLinkByIdParams::builder("1".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"downloadId":"545923594199212032","status":"processing","url":"","notified":false,"expirationTimestamp":-1,"isExpired":null}"#).unwrap();
            let expected_response : models::GetOptionTransactionHistoryDownloadLinkByIdResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetOptionTransactionHistoryDownloadLinkByIdResponse");

            let resp = client.get_option_transaction_history_download_link_by_id(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_option_transaction_history_download_link_by_id_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params =
                GetOptionTransactionHistoryDownloadLinkByIdParams::builder("1".to_string())
                    .build()
                    .unwrap();

            match client
                .get_option_transaction_history_download_link_by_id(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn option_account_information_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = OptionAccountInformationParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"asset":[{"asset":"USDT","marginBalance":"1877.52214415","equity":"617.77711415","available":"0","locked":"2898.92389933","unrealizedPNL":"222.23697000"}],"greek":[{"underlying":"BTCUSDT","delta":"-0.05","gamma":"-0.002","theta":"-0.05","vega":"-0.002"}],"time":1592449455993,"riskLevel":"NORMAL"}"#).unwrap();
            let expected_response : models::OptionAccountInformationResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OptionAccountInformationResponse");

            let resp = client.option_account_information(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn option_account_information_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = OptionAccountInformationParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"asset":[{"asset":"USDT","marginBalance":"1877.52214415","equity":"617.77711415","available":"0","locked":"2898.92389933","unrealizedPNL":"222.23697000"}],"greek":[{"underlying":"BTCUSDT","delta":"-0.05","gamma":"-0.002","theta":"-0.05","vega":"-0.002"}],"time":1592449455993,"riskLevel":"NORMAL"}"#).unwrap();
            let expected_response : models::OptionAccountInformationResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OptionAccountInformationResponse");

            let resp = client.option_account_information(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn option_account_information_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = OptionAccountInformationParams::builder().build().unwrap();

            match client.option_account_information(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
