/*
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::margin_trading::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountApi: Send + Sync {
    async fn adjust_cross_margin_max_leverage(
        &self,
        params: AdjustCrossMarginMaxLeverageParams,
    ) -> anyhow::Result<RestApiResponse<models::AdjustCrossMarginMaxLeverageResponse>>;
    async fn disable_isolated_margin_account(
        &self,
        params: DisableIsolatedMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::DisableIsolatedMarginAccountResponse>>;
    async fn enable_isolated_margin_account(
        &self,
        params: EnableIsolatedMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableIsolatedMarginAccountResponse>>;
    async fn get_bnb_burn_status(
        &self,
        params: GetBnbBurnStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnbBurnStatusResponse>>;
    async fn get_summary_of_margin_account(
        &self,
        params: GetSummaryOfMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSummaryOfMarginAccountResponse>>;
    async fn query_cross_isolated_margin_capital_flow(
        &self,
        params: QueryCrossIsolatedMarginCapitalFlowParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>>,
    >;
    async fn query_cross_margin_account_details(
        &self,
        params: QueryCrossMarginAccountDetailsParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCrossMarginAccountDetailsResponse>>;
    async fn query_cross_margin_fee_data(
        &self,
        params: QueryCrossMarginFeeDataParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCrossMarginFeeDataResponseInner>>>;
    async fn query_enabled_isolated_margin_account_limit(
        &self,
        params: QueryEnabledIsolatedMarginAccountLimitParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryEnabledIsolatedMarginAccountLimitResponse>>;
    async fn query_isolated_margin_account_info(
        &self,
        params: QueryIsolatedMarginAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryIsolatedMarginAccountInfoResponse>>;
    async fn query_isolated_margin_fee_data(
        &self,
        params: QueryIsolatedMarginFeeDataParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryIsolatedMarginFeeDataResponseInner>>>;
}

#[derive(Debug, Clone)]
pub struct AccountApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`adjust_cross_margin_max_leverage`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`adjust_cross_margin_max_leverage`](#method.adjust_cross_margin_max_leverage).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AdjustCrossMarginMaxLeverageParams {
    /// Can only adjust 3 , 5 or 10，Example: maxLeverage = 5 or 3 for Cross Margin Classic; maxLeverage=10 for Cross Margin Pro 10x leverage or 20x if compliance allows.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub max_leverage: i64,
}

impl AdjustCrossMarginMaxLeverageParams {
    /// Create a builder for [`adjust_cross_margin_max_leverage`].
    ///
    /// Required parameters:
    ///
    /// * `max_leverage` — Can only adjust 3 , 5 or 10，Example: maxLeverage = 5 or 3 for Cross Margin Classic; maxLeverage=10 for Cross Margin Pro 10x leverage or 20x if compliance allows.
    ///
    #[must_use]
    pub fn builder(max_leverage: i64) -> AdjustCrossMarginMaxLeverageParamsBuilder {
        AdjustCrossMarginMaxLeverageParamsBuilder::default().max_leverage(max_leverage)
    }
}
/// Request parameters for the [`disable_isolated_margin_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`disable_isolated_margin_account`](#method.disable_isolated_margin_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DisableIsolatedMarginAccountParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl DisableIsolatedMarginAccountParams {
    /// Create a builder for [`disable_isolated_margin_account`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DisableIsolatedMarginAccountParamsBuilder {
        DisableIsolatedMarginAccountParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`enable_isolated_margin_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`enable_isolated_margin_account`](#method.enable_isolated_margin_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct EnableIsolatedMarginAccountParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl EnableIsolatedMarginAccountParams {
    /// Create a builder for [`enable_isolated_margin_account`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> EnableIsolatedMarginAccountParamsBuilder {
        EnableIsolatedMarginAccountParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`get_bnb_burn_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_bnb_burn_status`](#method.get_bnb_burn_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetBnbBurnStatusParams {
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetBnbBurnStatusParams {
    /// Create a builder for [`get_bnb_burn_status`].
    ///
    #[must_use]
    pub fn builder() -> GetBnbBurnStatusParamsBuilder {
        GetBnbBurnStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`get_summary_of_margin_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_summary_of_margin_account`](#method.get_summary_of_margin_account).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetSummaryOfMarginAccountParams {
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetSummaryOfMarginAccountParams {
    /// Create a builder for [`get_summary_of_margin_account`].
    ///
    #[must_use]
    pub fn builder() -> GetSummaryOfMarginAccountParamsBuilder {
        GetSummaryOfMarginAccountParamsBuilder::default()
    }
}
/// Request parameters for the [`query_cross_isolated_margin_capital_flow`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cross_isolated_margin_capital_flow`](#method.query_cross_isolated_margin_capital_flow).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCrossIsolatedMarginCapitalFlowParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    /// isolated margin pair
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// Transfer Type: `ROLL_IN`, `ROLL_OUT`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<String>,
    /// 只支持查询最近90天的数据
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Default Value: 500; Max Value: 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCrossIsolatedMarginCapitalFlowParams {
    /// Create a builder for [`query_cross_isolated_margin_capital_flow`].
    ///
    #[must_use]
    pub fn builder() -> QueryCrossIsolatedMarginCapitalFlowParamsBuilder {
        QueryCrossIsolatedMarginCapitalFlowParamsBuilder::default()
    }
}
/// Request parameters for the [`query_cross_margin_account_details`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cross_margin_account_details`](#method.query_cross_margin_account_details).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCrossMarginAccountDetailsParams {
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCrossMarginAccountDetailsParams {
    /// Create a builder for [`query_cross_margin_account_details`].
    ///
    #[must_use]
    pub fn builder() -> QueryCrossMarginAccountDetailsParamsBuilder {
        QueryCrossMarginAccountDetailsParamsBuilder::default()
    }
}
/// Request parameters for the [`query_cross_margin_fee_data`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cross_margin_fee_data`](#method.query_cross_margin_fee_data).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCrossMarginFeeDataParams {
    /// User's current specific margin data will be returned if vipLevel is omitted
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub vip_level: Option<i64>,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub coin: Option<String>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCrossMarginFeeDataParams {
    /// Create a builder for [`query_cross_margin_fee_data`].
    ///
    #[must_use]
    pub fn builder() -> QueryCrossMarginFeeDataParamsBuilder {
        QueryCrossMarginFeeDataParamsBuilder::default()
    }
}
/// Request parameters for the [`query_enabled_isolated_margin_account_limit`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_enabled_isolated_margin_account_limit`](#method.query_enabled_isolated_margin_account_limit).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryEnabledIsolatedMarginAccountLimitParams {
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryEnabledIsolatedMarginAccountLimitParams {
    /// Create a builder for [`query_enabled_isolated_margin_account_limit`].
    ///
    #[must_use]
    pub fn builder() -> QueryEnabledIsolatedMarginAccountLimitParamsBuilder {
        QueryEnabledIsolatedMarginAccountLimitParamsBuilder::default()
    }
}
/// Request parameters for the [`query_isolated_margin_account_info`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_isolated_margin_account_info`](#method.query_isolated_margin_account_info).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryIsolatedMarginAccountInfoParams {
    /// Max 5 symbols can be sent; separated by ",". e.g. "BTCUSDT,BNBUSDT,ADAUSDT"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<String>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryIsolatedMarginAccountInfoParams {
    /// Create a builder for [`query_isolated_margin_account_info`].
    ///
    #[must_use]
    pub fn builder() -> QueryIsolatedMarginAccountInfoParamsBuilder {
        QueryIsolatedMarginAccountInfoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_isolated_margin_fee_data`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_isolated_margin_fee_data`](#method.query_isolated_margin_fee_data).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryIsolatedMarginFeeDataParams {
    /// User's current specific margin data will be returned if vipLevel is omitted
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub vip_level: Option<i64>,
    /// isolated margin pair
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryIsolatedMarginFeeDataParams {
    /// Create a builder for [`query_isolated_margin_fee_data`].
    ///
    #[must_use]
    pub fn builder() -> QueryIsolatedMarginFeeDataParamsBuilder {
        QueryIsolatedMarginFeeDataParamsBuilder::default()
    }
}

#[async_trait]
impl AccountApi for AccountApiClient {
    async fn adjust_cross_margin_max_leverage(
        &self,
        params: AdjustCrossMarginMaxLeverageParams,
    ) -> anyhow::Result<RestApiResponse<models::AdjustCrossMarginMaxLeverageResponse>> {
        let AdjustCrossMarginMaxLeverageParams { max_leverage } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("maxLeverage".to_string(), json!(max_leverage));

        send_request::<models::AdjustCrossMarginMaxLeverageResponse>(
            &self.configuration,
            "/sapi/v1/margin/max-leverage",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn disable_isolated_margin_account(
        &self,
        params: DisableIsolatedMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::DisableIsolatedMarginAccountResponse>> {
        let DisableIsolatedMarginAccountParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::DisableIsolatedMarginAccountResponse>(
            &self.configuration,
            "/sapi/v1/margin/isolated/account",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn enable_isolated_margin_account(
        &self,
        params: EnableIsolatedMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableIsolatedMarginAccountResponse>> {
        let EnableIsolatedMarginAccountParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::EnableIsolatedMarginAccountResponse>(
            &self.configuration,
            "/sapi/v1/margin/isolated/account",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_bnb_burn_status(
        &self,
        params: GetBnbBurnStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnbBurnStatusResponse>> {
        let GetBnbBurnStatusParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetBnbBurnStatusResponse>(
            &self.configuration,
            "/sapi/v1/bnbBurn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_summary_of_margin_account(
        &self,
        params: GetSummaryOfMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSummaryOfMarginAccountResponse>> {
        let GetSummaryOfMarginAccountParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetSummaryOfMarginAccountResponse>(
            &self.configuration,
            "/sapi/v1/margin/tradeCoeff",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cross_isolated_margin_capital_flow(
        &self,
        params: QueryCrossIsolatedMarginCapitalFlowParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>>,
    > {
        let QueryCrossIsolatedMarginCapitalFlowParams {
            asset,
            symbol,
            r#type,
            start_time,
            end_time,
            from_id,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>>(
            &self.configuration,
            "/sapi/v1/margin/capital-flow",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cross_margin_account_details(
        &self,
        params: QueryCrossMarginAccountDetailsParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCrossMarginAccountDetailsResponse>> {
        let QueryCrossMarginAccountDetailsParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCrossMarginAccountDetailsResponse>(
            &self.configuration,
            "/sapi/v1/margin/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cross_margin_fee_data(
        &self,
        params: QueryCrossMarginFeeDataParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCrossMarginFeeDataResponseInner>>> {
        let QueryCrossMarginFeeDataParams {
            vip_level,
            coin,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = vip_level {
            query_params.insert("vipLevel".to_string(), json!(rw));
        }

        if let Some(rw) = coin {
            query_params.insert("coin".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryCrossMarginFeeDataResponseInner>>(
            &self.configuration,
            "/sapi/v1/margin/crossMarginData",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_enabled_isolated_margin_account_limit(
        &self,
        params: QueryEnabledIsolatedMarginAccountLimitParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryEnabledIsolatedMarginAccountLimitResponse>>
    {
        let QueryEnabledIsolatedMarginAccountLimitParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryEnabledIsolatedMarginAccountLimitResponse>(
            &self.configuration,
            "/sapi/v1/margin/isolated/accountLimit",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_isolated_margin_account_info(
        &self,
        params: QueryIsolatedMarginAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryIsolatedMarginAccountInfoResponse>> {
        let QueryIsolatedMarginAccountInfoParams {
            symbols,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryIsolatedMarginAccountInfoResponse>(
            &self.configuration,
            "/sapi/v1/margin/isolated/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_isolated_margin_fee_data(
        &self,
        params: QueryIsolatedMarginFeeDataParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryIsolatedMarginFeeDataResponseInner>>> {
        let QueryIsolatedMarginFeeDataParams {
            vip_level,
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = vip_level {
            query_params.insert("vipLevel".to_string(), json!(rw));
        }

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryIsolatedMarginFeeDataResponseInner>>(
            &self.configuration,
            "/sapi/v1/margin/isolatedMarginData",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "margin_trading"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountApi for MockAccountApiClient {
        async fn adjust_cross_margin_max_leverage(
            &self,
            _params: AdjustCrossMarginMaxLeverageParams,
        ) -> anyhow::Result<RestApiResponse<models::AdjustCrossMarginMaxLeverageResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let dummy_response: models::AdjustCrossMarginMaxLeverageResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AdjustCrossMarginMaxLeverageResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn disable_isolated_margin_account(
            &self,
            _params: DisableIsolatedMarginAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::DisableIsolatedMarginAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let dummy_response: models::DisableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DisableIsolatedMarginAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn enable_isolated_margin_account(
            &self,
            _params: EnableIsolatedMarginAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::EnableIsolatedMarginAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let dummy_response: models::EnableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableIsolatedMarginAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_bnb_burn_status(
            &self,
            _params: GetBnbBurnStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::GetBnbBurnStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"spotBNBBurn":true,"interestBNBBurn":false}"#).unwrap();
            let dummy_response: models::GetBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBnbBurnStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_summary_of_margin_account(
            &self,
            _params: GetSummaryOfMarginAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::GetSummaryOfMarginAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"normalBar":"1.5","marginCallBar":"1.3","forceLiquidationBar":"1.1"}"#,
            )
            .unwrap();
            let dummy_response: models::GetSummaryOfMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSummaryOfMarginAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cross_isolated_margin_capital_flow(
            &self,
            _params: QueryCrossIsolatedMarginCapitalFlowParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":123456,"tranId":123123,"timestamp":1691116657000,"asset":"USDT","symbol":"BTCUSDT","type":"BORROW","amount":"101"},{"id":123457,"tranId":123124,"timestamp":1691116658000,"asset":"BTC","symbol":"BTCUSDT","type":"REPAY","amount":"10"}]"#).unwrap();
            let dummy_response : Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cross_margin_account_details(
            &self,
            _params: QueryCrossMarginAccountDetailsParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCrossMarginAccountDetailsResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"created":true,"borrowEnabled":true,"marginLevel":"11.64405625","collateralMarginLevel":"3.2","totalAssetOfBtc":"6.82728457","totalLiabilityOfBtc":"0.58633215","totalNetAssetOfBtc":"6.24095242","TotalCollateralValueInUSDT":"5.82728457","totalOpenOrderLossInUSDT":"582.728457","tradeEnabled":true,"transferInEnabled":true,"transferOutEnabled":true,"accountType":"MARGIN_1","userAssets":[{"asset":"BTC","borrowed":"0.00000000","free":"0.00499500","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00499500"},{"asset":"BNB","borrowed":"201.66666672","free":"2346.50000000","interest":"0.00000000","locked":"0.00000000","netAsset":"2144.83333328"},{"asset":"ETH","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},{"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}]}"#).unwrap();
            let dummy_response: models::QueryCrossMarginAccountDetailsResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCrossMarginAccountDetailsResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cross_margin_fee_data(
            &self,
            _params: QueryCrossMarginFeeDataParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCrossMarginFeeDataResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"coin":"BTC","transferIn":true,"borrowable":true,"dailyInterest":"0.00026125","yearlyInterest":"0.0953","borrowLimit":"180","marginablePairs":["BNBBTC","TRXBTC","ETHBTC","BTCUSDT"]}]"#).unwrap();
            let dummy_response: Vec<models::QueryCrossMarginFeeDataResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::QueryCrossMarginFeeDataResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_enabled_isolated_margin_account_limit(
            &self,
            _params: QueryEnabledIsolatedMarginAccountLimitParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryEnabledIsolatedMarginAccountLimitResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"enabledAccount":5,"maxAccount":20}"#).unwrap();
            let dummy_response: models::QueryEnabledIsolatedMarginAccountLimitResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryEnabledIsolatedMarginAccountLimitResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_isolated_margin_account_info(
            &self,
            _params: QueryIsolatedMarginAccountInfoParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryIsolatedMarginAccountInfoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true},{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true}],"totalAssetOfBtc":"0.00000000","totalLiabilityOfBtc":"0.00000000","totalNetAssetOfBtc":"0.00000000"}"#).unwrap();
            let dummy_response: models::QueryIsolatedMarginAccountInfoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryIsolatedMarginAccountInfoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_isolated_margin_fee_data(
            &self,
            _params: QueryIsolatedMarginFeeDataParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryIsolatedMarginFeeDataResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"symbol":"BTCUSDT","leverage":"10","data":[{"coin":"BTC","dailyInterest":"0.00026125","borrowLimit":"270"},{"coin":"USDT","dailyInterest":"0.000475","borrowLimit":"2100000"}]}]"#).unwrap();
            let dummy_response: Vec<models::QueryIsolatedMarginFeeDataResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryIsolatedMarginFeeDataResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn adjust_cross_margin_max_leverage_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AdjustCrossMarginMaxLeverageParams::builder(789)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let expected_response: models::AdjustCrossMarginMaxLeverageResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AdjustCrossMarginMaxLeverageResponse");

            let resp = client
                .adjust_cross_margin_max_leverage(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn adjust_cross_margin_max_leverage_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = AdjustCrossMarginMaxLeverageParams::builder(789)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let expected_response: models::AdjustCrossMarginMaxLeverageResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AdjustCrossMarginMaxLeverageResponse");

            let resp = client
                .adjust_cross_margin_max_leverage(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn adjust_cross_margin_max_leverage_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = AdjustCrossMarginMaxLeverageParams::builder(789)
                .build()
                .unwrap();

            match client.adjust_cross_margin_max_leverage(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn disable_isolated_margin_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DisableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let expected_response: models::DisableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DisableIsolatedMarginAccountResponse");

            let resp = client
                .disable_isolated_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn disable_isolated_margin_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = DisableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let expected_response: models::DisableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::DisableIsolatedMarginAccountResponse");

            let resp = client
                .disable_isolated_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn disable_isolated_margin_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = DisableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.disable_isolated_margin_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn enable_isolated_margin_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = EnableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let expected_response: models::EnableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableIsolatedMarginAccountResponse");

            let resp = client
                .enable_isolated_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_isolated_margin_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = EnableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"success":true,"symbol":"BTCUSDT"}"#).unwrap();
            let expected_response: models::EnableIsolatedMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableIsolatedMarginAccountResponse");

            let resp = client
                .enable_isolated_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_isolated_margin_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = EnableIsolatedMarginAccountParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.enable_isolated_margin_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_bnb_burn_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetBnbBurnStatusParams::builder().build().unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"spotBNBBurn":true,"interestBNBBurn":false}"#).unwrap();
            let expected_response: models::GetBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBnbBurnStatusResponse");

            let resp = client
                .get_bnb_burn_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnb_burn_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetBnbBurnStatusParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"spotBNBBurn":true,"interestBNBBurn":false}"#).unwrap();
            let expected_response: models::GetBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBnbBurnStatusResponse");

            let resp = client
                .get_bnb_burn_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnb_burn_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetBnbBurnStatusParams::builder().build().unwrap();

            match client.get_bnb_burn_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_summary_of_margin_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetSummaryOfMarginAccountParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"normalBar":"1.5","marginCallBar":"1.3","forceLiquidationBar":"1.1"}"#,
            )
            .unwrap();
            let expected_response: models::GetSummaryOfMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSummaryOfMarginAccountResponse");

            let resp = client
                .get_summary_of_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_summary_of_margin_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetSummaryOfMarginAccountParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"normalBar":"1.5","marginCallBar":"1.3","forceLiquidationBar":"1.1"}"#,
            )
            .unwrap();
            let expected_response: models::GetSummaryOfMarginAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSummaryOfMarginAccountResponse");

            let resp = client
                .get_summary_of_margin_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_summary_of_margin_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetSummaryOfMarginAccountParams::builder().build().unwrap();

            match client.get_summary_of_margin_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cross_isolated_margin_capital_flow_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossIsolatedMarginCapitalFlowParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":123456,"tranId":123123,"timestamp":1691116657000,"asset":"USDT","symbol":"BTCUSDT","type":"BORROW","amount":"101"},{"id":123457,"tranId":123124,"timestamp":1691116658000,"asset":"BTC","symbol":"BTCUSDT","type":"REPAY","amount":"10"}]"#).unwrap();
            let expected_response : Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>");

            let resp = client.query_cross_isolated_margin_capital_flow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_isolated_margin_capital_flow_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossIsolatedMarginCapitalFlowParams::builder().asset("asset_example".to_string()).symbol("symbol_example".to_string()).r#type("r#type_example".to_string()).start_time(1623319461670).end_time(1641782889000).from_id(1).limit(500).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":123456,"tranId":123123,"timestamp":1691116657000,"asset":"USDT","symbol":"BTCUSDT","type":"BORROW","amount":"101"},{"id":123457,"tranId":123124,"timestamp":1691116658000,"asset":"BTC","symbol":"BTCUSDT","type":"REPAY","amount":"10"}]"#).unwrap();
            let expected_response : Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCrossIsolatedMarginCapitalFlowResponseInner>");

            let resp = client.query_cross_isolated_margin_capital_flow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_isolated_margin_capital_flow_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryCrossIsolatedMarginCapitalFlowParams::builder()
                .build()
                .unwrap();

            match client
                .query_cross_isolated_margin_capital_flow(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cross_margin_account_details_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossMarginAccountDetailsParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"created":true,"borrowEnabled":true,"marginLevel":"11.64405625","collateralMarginLevel":"3.2","totalAssetOfBtc":"6.82728457","totalLiabilityOfBtc":"0.58633215","totalNetAssetOfBtc":"6.24095242","TotalCollateralValueInUSDT":"5.82728457","totalOpenOrderLossInUSDT":"582.728457","tradeEnabled":true,"transferInEnabled":true,"transferOutEnabled":true,"accountType":"MARGIN_1","userAssets":[{"asset":"BTC","borrowed":"0.00000000","free":"0.00499500","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00499500"},{"asset":"BNB","borrowed":"201.66666672","free":"2346.50000000","interest":"0.00000000","locked":"0.00000000","netAsset":"2144.83333328"},{"asset":"ETH","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},{"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}]}"#).unwrap();
            let expected_response : models::QueryCrossMarginAccountDetailsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCrossMarginAccountDetailsResponse");

            let resp = client.query_cross_margin_account_details(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_margin_account_details_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossMarginAccountDetailsParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"created":true,"borrowEnabled":true,"marginLevel":"11.64405625","collateralMarginLevel":"3.2","totalAssetOfBtc":"6.82728457","totalLiabilityOfBtc":"0.58633215","totalNetAssetOfBtc":"6.24095242","TotalCollateralValueInUSDT":"5.82728457","totalOpenOrderLossInUSDT":"582.728457","tradeEnabled":true,"transferInEnabled":true,"transferOutEnabled":true,"accountType":"MARGIN_1","userAssets":[{"asset":"BTC","borrowed":"0.00000000","free":"0.00499500","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00499500"},{"asset":"BNB","borrowed":"201.66666672","free":"2346.50000000","interest":"0.00000000","locked":"0.00000000","netAsset":"2144.83333328"},{"asset":"ETH","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},{"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}]}"#).unwrap();
            let expected_response : models::QueryCrossMarginAccountDetailsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCrossMarginAccountDetailsResponse");

            let resp = client.query_cross_margin_account_details(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_margin_account_details_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryCrossMarginAccountDetailsParams::builder()
                .build()
                .unwrap();

            match client.query_cross_margin_account_details(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cross_margin_fee_data_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossMarginFeeDataParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"coin":"BTC","transferIn":true,"borrowable":true,"dailyInterest":"0.00026125","yearlyInterest":"0.0953","borrowLimit":"180","marginablePairs":["BNBBTC","TRXBTC","ETHBTC","BTCUSDT"]}]"#).unwrap();
            let expected_response : Vec<models::QueryCrossMarginFeeDataResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCrossMarginFeeDataResponseInner>");

            let resp = client.query_cross_margin_fee_data(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_margin_fee_data_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryCrossMarginFeeDataParams::builder().vip_level(1).coin("coin_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"coin":"BTC","transferIn":true,"borrowable":true,"dailyInterest":"0.00026125","yearlyInterest":"0.0953","borrowLimit":"180","marginablePairs":["BNBBTC","TRXBTC","ETHBTC","BTCUSDT"]}]"#).unwrap();
            let expected_response : Vec<models::QueryCrossMarginFeeDataResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCrossMarginFeeDataResponseInner>");

            let resp = client.query_cross_margin_fee_data(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cross_margin_fee_data_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryCrossMarginFeeDataParams::builder().build().unwrap();

            match client.query_cross_margin_fee_data(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_enabled_isolated_margin_account_limit_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryEnabledIsolatedMarginAccountLimitParams::builder()
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"enabledAccount":5,"maxAccount":20}"#).unwrap();
            let expected_response: models::QueryEnabledIsolatedMarginAccountLimitResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryEnabledIsolatedMarginAccountLimitResponse",
                );

            let resp = client
                .query_enabled_isolated_margin_account_limit(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_enabled_isolated_margin_account_limit_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryEnabledIsolatedMarginAccountLimitParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"enabledAccount":5,"maxAccount":20}"#).unwrap();
            let expected_response: models::QueryEnabledIsolatedMarginAccountLimitResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryEnabledIsolatedMarginAccountLimitResponse",
                );

            let resp = client
                .query_enabled_isolated_margin_account_limit(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_enabled_isolated_margin_account_limit_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryEnabledIsolatedMarginAccountLimitParams::builder()
                .build()
                .unwrap();

            match client
                .query_enabled_isolated_margin_account_limit(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_isolated_margin_account_info_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryIsolatedMarginAccountInfoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true},{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true}],"totalAssetOfBtc":"0.00000000","totalLiabilityOfBtc":"0.00000000","totalNetAssetOfBtc":"0.00000000"}"#).unwrap();
            let expected_response : models::QueryIsolatedMarginAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryIsolatedMarginAccountInfoResponse");

            let resp = client.query_isolated_margin_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_isolated_margin_account_info_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryIsolatedMarginAccountInfoParams::builder().symbols("symbols_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"assets":[{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true},{"baseAsset":{"asset":"BTC","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"quoteAsset":{"asset":"USDT","borrowEnabled":true,"borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000","netAssetOfBtc":"0.00000000","repayEnabled":true,"totalAsset":"0.00000000"},"symbol":"BTCUSDT","isolatedCreated":true,"enabled":true,"marginLevel":"0.00000000","marginLevelStatus":"EXCESSIVE","marginRatio":"0.00000000","indexPrice":"10000.00000000","liquidatePrice":"1000.00000000","liquidateRate":"1.00000000","tradeEnabled":true}],"totalAssetOfBtc":"0.00000000","totalLiabilityOfBtc":"0.00000000","totalNetAssetOfBtc":"0.00000000"}"#).unwrap();
            let expected_response : models::QueryIsolatedMarginAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryIsolatedMarginAccountInfoResponse");

            let resp = client.query_isolated_margin_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_isolated_margin_account_info_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryIsolatedMarginAccountInfoParams::builder()
                .build()
                .unwrap();

            match client.query_isolated_margin_account_info(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_isolated_margin_fee_data_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryIsolatedMarginFeeDataParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"symbol":"BTCUSDT","leverage":"10","data":[{"coin":"BTC","dailyInterest":"0.00026125","borrowLimit":"270"},{"coin":"USDT","dailyInterest":"0.000475","borrowLimit":"2100000"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryIsolatedMarginFeeDataResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryIsolatedMarginFeeDataResponseInner>");

            let resp = client.query_isolated_margin_fee_data(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_isolated_margin_fee_data_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryIsolatedMarginFeeDataParams::builder().vip_level(1).symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"vipLevel":0,"symbol":"BTCUSDT","leverage":"10","data":[{"coin":"BTC","dailyInterest":"0.00026125","borrowLimit":"270"},{"coin":"USDT","dailyInterest":"0.000475","borrowLimit":"2100000"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryIsolatedMarginFeeDataResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryIsolatedMarginFeeDataResponseInner>");

            let resp = client.query_isolated_margin_fee_data(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_isolated_margin_fee_data_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryIsolatedMarginFeeDataParams::builder().build().unwrap();

            match client.query_isolated_margin_fee_data(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
